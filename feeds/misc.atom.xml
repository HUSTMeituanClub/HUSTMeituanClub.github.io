<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>美团点评技术俱乐部 - misc</title><link href="/" rel="alternate"></link><link href="/feeds/misc.atom.xml" rel="self"></link><id>/</id><updated>2017-04-04T16:50:20+08:00</updated><entry><title>深入理解计算机系统DataLab实验报告</title><link href="/shen-ru-li-jie-ji-suan-ji-xi-tong-datalabshi-yan-bao-gao.html" rel="alternate"></link><published>2017-04-04T16:50:20+08:00</published><updated>2017-04-04T16:50:20+08:00</updated><author><name>Zhihao Chen</name></author><id>tag:None,2017-04-04:/shen-ru-li-jie-ji-suan-ji-xi-tong-datalabshi-yan-bao-gao.html</id><summary type="html">&lt;p&gt;实验答案托管在我的&lt;a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/DataLab"&gt;GitHub&lt;/a&gt;上&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总共花了五天时间完成了《深入理解计算机系统》(Computer Science A Programmer's Perspective)的第一个Lab - Data Lab，深感这次实验的效率低下。一方面是由于清明假期自己有所惰怠，另一方面也是由于在做题的时候采取了不正确的方法，在已经明知不会的情况下我还继续投入大量无意义的时间，没有取得很好的学习效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;实验简介&lt;/h2&gt;
&lt;p&gt;Data Lab - Manipulating Bits主要是关于位操作的实验，对应于书本的第2章：信息的表示和处理。&lt;/p&gt;
&lt;p&gt;在该实验中，学生主要需要在一个严格限制的C子集（使用优先的位运算符以及顺序结构的代码）中实现简单的逻辑，补码以及浮点数相关的函数。本实验的目的是为了让学生熟悉整数和浮点数的位级表示。&lt;/p&gt;
&lt;p&gt;本实验的核心在于在各种受限制的条件下完成给出的15个谜题。其中包括5个位操作的谜题，7个补码运算的谜题，以及3个浮点数操作的谜题。其中每完成一个谜题都能得到一定的分数，如果使用的运算符数目小于给定的数目，还能获得加分。本实验的满分是71分。可以通过讲义中的driver.pl脚本直接计算出总分数。&lt;/p&gt;
&lt;p&gt;关于本实验具体的介绍详见&lt;a href="http://csapp.cs.cmu.edu/3e/datalab-handout.tar"&gt;实验讲义&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;测试程序btest make失败及解决办法&lt;/h2&gt;
&lt;p&gt;在完成实验的功能中需要用到&lt;code&gt;make &amp;amp;&amp;amp; ./btest&lt;/code&gt;命令进行答案正确性的检查，结果系统返回了 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;实验答案托管在我的&lt;a href="https://github.com/BlackDragonF/CSAPPLabs/tree/master/DataLab"&gt;GitHub&lt;/a&gt;上&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总共花了五天时间完成了《深入理解计算机系统》(Computer Science A Programmer's Perspective)的第一个Lab - Data Lab，深感这次实验的效率低下。一方面是由于清明假期自己有所惰怠，另一方面也是由于在做题的时候采取了不正确的方法，在已经明知不会的情况下我还继续投入大量无意义的时间，没有取得很好的学习效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;实验简介&lt;/h2&gt;
&lt;p&gt;Data Lab - Manipulating Bits主要是关于位操作的实验，对应于书本的第2章：信息的表示和处理。&lt;/p&gt;
&lt;p&gt;在该实验中，学生主要需要在一个严格限制的C子集（使用优先的位运算符以及顺序结构的代码）中实现简单的逻辑，补码以及浮点数相关的函数。本实验的目的是为了让学生熟悉整数和浮点数的位级表示。&lt;/p&gt;
&lt;p&gt;本实验的核心在于在各种受限制的条件下完成给出的15个谜题。其中包括5个位操作的谜题，7个补码运算的谜题，以及3个浮点数操作的谜题。其中每完成一个谜题都能得到一定的分数，如果使用的运算符数目小于给定的数目，还能获得加分。本实验的满分是71分。可以通过讲义中的driver.pl脚本直接计算出总分数。&lt;/p&gt;
&lt;p&gt;关于本实验具体的介绍详见&lt;a href="http://csapp.cs.cmu.edu/3e/datalab-handout.tar"&gt;实验讲义&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;测试程序btest make失败及解决办法&lt;/h2&gt;
&lt;p&gt;在完成实验的功能中需要用到&lt;code&gt;make &amp;amp;&amp;amp; ./btest&lt;/code&gt;命令进行答案正确性的检查，结果系统返回了&lt;code&gt;fetal error: gnu/stubs-32.h:No such file or directory&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;经过检查发现是系统是Archlinux 64位，而Makefile中包含了-m32的编译参数导致的。&lt;/p&gt;
&lt;p&gt;通过启用multilib仓库使得可以在64位的ArchLinux系统上编译和运行32位的程序，问题得以解决。&lt;/p&gt;
&lt;p&gt;编辑/etc/pacman.conf，取消下面内容的注释：&lt;/p&gt;
&lt;p _="%" endcodeblock&gt;{% codeblock lang:vim %}
[multilib]
include = /etc/pacman.d/mirrorlist&lt;/p&gt;
&lt;p&gt;更新软件包列表并升级系统&lt;code&gt;pacman -Syu&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后安装gcc-multilib并重新执行&lt;code&gt;make &amp;amp;&amp;amp; ./btest&lt;/code&gt;，问题解决。&lt;/p&gt;
&lt;h2&gt;实验限制&lt;/h2&gt;
&lt;h3&gt;整数代码规则&lt;/h3&gt;
&lt;p _="%" endcodeblock&gt;整数代码应遵循如下的基本结构：
{% codeblock lang:c %}
int Funct(arg1, arg2, ...) {
    /&lt;em&gt; brief description of how your implementation works &lt;/em&gt;/
    int var1 = Expr1;
    ...
    int varM = ExprM;
    varJ = ExprJ;
    ...
    varN = ExprN;
    return ExprR;
}&lt;/p&gt;
&lt;p&gt;每一个表达式只能使用：
1. 0～255之间的常量（包括0和255）
2. 函数的参数和局部变量
3. 单目运算符 ! ~
4. 双目运算符 &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;注意，部分题目对于运算符有着更加严格的限制，但是你可以在一行代码中使用多个运算符。&lt;/p&gt;
&lt;p&gt;你将会被禁止：
1. 使用任何的分支或者循环结构
2. 定义或者使用任何的宏
3. 在文件中定义任何额外函数
4. 调用任何函数
5. 使用任何其他的运算符
6. 使用任何形式的类型转换
7. 使用除了int意外的其他数据类型，这意味着你不能使用数组，结构或联合&lt;/p&gt;
&lt;p&gt;你可以假设你的机器：
1. 使用32位补码表示整数
2. 使用算术右移
3. 对整数进行的位移运算的位数超越了字长是未定义的行为&lt;/p&gt;
&lt;h3&gt;浮点代码规则&lt;/h3&gt;
&lt;p&gt;浮点运算的规则相对较为宽松，你可以使用循环或者是分支结构，你被允许同时使用int和unsigned，此外，你还可以使用任意的常量。&lt;/p&gt;
&lt;p&gt;你将会被禁止：
1. 定义或者使用任何的宏
2. 在文件中定义任何额外函数
3. 调用任何函数
4. 使用任何形式的类型转换
5. 使用除了int和unsigned以外的任何数据类型，这意味着你不能使用数组，结构或者联合
6. 使用任何浮点数的数据类型，操作或者是常量&lt;/p&gt;
&lt;h2&gt;实验答案及分析&lt;/h2&gt;
&lt;h3&gt;第一部分 位操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;bitAnd
    问题：要求使用~和|以及不超过8个操作符实现x&amp;amp;y
    分析：使用De Morgan定律即可
    答案：
    {% codeblock lang:c %}
    int bitAnd(int x, int y) {
    /&lt;em&gt; x&amp;amp;y = ~(~(x&amp;amp;y)) = ~(~x|~y) &lt;/em&gt;/
        return ~(~x | ~y);
    }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;getByte
    问题：要求使用! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;以及不超过6个操作符返回x中的第n个字节(0(LSB)&amp;lt;=n&amp;lt;=3(MSB))。
    分析：根据不同的n值将x右移不同的位数，然后使用掩码0xFF取得最低位数的字节即可。先左移再右移会导致算术右移，需要小心。
    答案：
    {% codeblock lang:c %}
    int getByte(int x, int n) {
    /&lt;em&gt; right shift in order to avoid boring arithmatic shift and try to get specific byte using bitAnd and mask. &lt;/em&gt;/
        return ((x &amp;gt;&amp;gt; (n &amp;lt;&amp;lt; 3)) &amp;amp; 0xFF);      &lt;br&gt;
    }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;logicalShift
    问题：要求使用! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;以及不超过20个操作符实现将int值x的逻辑右移n位。
    分析：通过将一个全1的数通过算术右移的方式构造掩码，然后与算术右移的掩码求按位与即可。
    注意，直接右移32位的结果是未定义的，需要额外处理这种情况。
    答案：
    {% codeblock lang:c %}
    int logicalShift(int x, int n) {
    /&lt;em&gt; try to implement logical right shift by mask and logical right shift &lt;/em&gt;/
        int mask = ((~0) &amp;lt;&amp;lt; (31 + (~n + 1))) &amp;lt;&amp;lt; 1;
        return (x &amp;gt;&amp;gt; n) &amp;amp; (~mask);
    }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;bitCount
     问题：要求使用! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;以及不超过40个操作符计算一个数字x中有多少为1的位。
     分析：
     本题参考&lt;a href="http://stackoverflow.com/questions/3815165/how-to-implement-bitcount-using-only-bitwise-operators"&gt;stackoverflow&lt;/a&gt;上的回答，并结合题目要求做了一些改动。
     核心的思想是分治法，通过将原数字x中的位按每1,2,4...个位分组，按相邻组进行累加，最后求出结果。
     举例来说，假如现在有一个数395，它的二进制表示是0000000110001011(16位)，首先我们将这个数按1位分组，得到：
     0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1
     然后我们将相邻的组累加，得到：
     0+0 0+0 0+0 0+1 1+0 0+0 1+0 1+1
     00 00 00 01 01 00 01 10
     然后我们继续将相邻的组累加，得到：
     00+00 00+01 01+00 01+10
     0000 0001 0001 0011
     然后我们继续将相邻的组累加，得到：
     0000+0001 0001+0011
     00000001 00000100
     最后，我们最后的两个组累加，得到：
     00000001+0000100=00000101
     结果是5，为正确答案。
     答案：
     {% codeblock lang:c %}
     int bitCount(int x) {
    /&lt;em&gt; Divide and Conquer &lt;/em&gt;/
        int mask = 0x55 + (0x55 &amp;lt;&amp;lt; 8) + (0x55 &amp;lt;&amp;lt; 16) + (0x55 &amp;lt;&amp;lt; 24);
        x = (x &amp;amp; mask) + ((x &amp;gt;&amp;gt; 1) &amp;amp; mask);
        mask = 0x33 + (0x33 &amp;lt;&amp;lt; 8) + (0x33 &amp;lt;&amp;lt; 16) + (0x33 &amp;lt;&amp;lt; 24);
        x = (x &amp;amp; mask) + ((x &amp;gt;&amp;gt; 2) &amp;amp; mask);
        mask = 0xF + (0xF &amp;lt;&amp;lt; 8) + (0xF &amp;lt;&amp;lt; 16) + (0xF &amp;lt;&amp;lt; 24);
        x = (x &amp;amp; mask) + ((x &amp;gt;&amp;gt; 4) &amp;amp; mask);
        return (x + (x &amp;gt;&amp;gt; 8) + (x &amp;gt;&amp;gt; 16) + (x &amp;gt;&amp;gt; 24)) &amp;amp; 0xFF;
    }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;bang
    问题：要求使用~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;以及不超过12个操作数计算x的逻辑非。
    分析：
    逻辑非要求将0变成1，将非0的数变成0。生成0或1可以通过与掩码0x1求按位与实现，重点在于如何构造一个表达式使得0和非0的数产生不同的结果。
    可以考虑对于任意一个非0的数，它的负数都是从最高位到其最低位的1为止(不包括最低位的1)全部取反的结果。
    例如，14是00001110(8位)，而-14是11110010(8位)，为14从最高位到最低位的1(不包括这个1)，也就是000011取反，而最低位的10不变的结果。
    而0的负数永远是0。
    从这里我们可以看出，对于一个非0的数，它与它的负数按位或的结果的最高位一定会是1，而0与非0的按位或的结果的最高位永远是0。我们可以以此实现逻辑非。
    答案：
    {% codeblock lang:c %}
    int bang(int x) {
    /&lt;em&gt; for x != 0, the highest bit of x | (-x) will always become 1 while when x == 0, the result is the opposite &lt;/em&gt;/
        return (~((x | (~x + 1)) &amp;gt;&amp;gt; 31) &amp;amp; 1);
    }&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第二部分 补码运算&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;tmin
    问题：要求使用! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;以及不超过4个运算符返回以补码表示的最小的整数。
    分析：根据补码到整数的公式，最小的整数的补码表示为10000...
    答案：
    {% codeblock lang:c %}
    int tmin(void) {
        /&lt;em&gt; TMin = 10000.... &lt;/em&gt;/
        return (1 &amp;lt;&amp;lt; 31);
    }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fitsBits
    问题：要求使用! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;以及不超过15个操作符判断x是否能表示成n位的补码，如果是，则返回1，反之则返回0。
    分析：
    这个问题需要分正数和负数两种情况讨论，对于正数来说，如果一个数x能表示成n位的补码，那么它从最高位直到第n位一定全部为0，它的第n位一定不能为1，否则它就会变成一个负数。对于一个负数来说，如果一个数x能表示成n位的补码，那么它只需从最高位到第n位全部为1即可。
    因此，我们可以先将x右移n-1位，对于满足条件的正数和负数，这将产生一个全0的数或是一个全1的数。然后我们可以根据x的符号构造一个全0或者是全1的掩码。通过将这两个数按位异或并且取逻辑非，就能得到正确的结果。
    答案：
    {% codeblock lang:c %}
    int fitsBits(int x, int n) {
    /* if fitsBits then from highest bit to n bit will all become 1 - negative number or 0 - positive number&lt;/p&gt;
&lt;ul&gt;
&lt;li _="%" endcodeblock&gt;then can construct a mask to implement fitsBits with the help of ^ and !
 */
    return !((x &amp;gt;&amp;gt; (n + (~1) + 1)) ^ (((1 &amp;lt;&amp;lt; 31) &amp;amp; x) &amp;gt;&amp;gt; 31));
}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;divpwr2
    问题：要求使用! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;以及不超过15个操作符求出x/(2^n)的结果，其中0&amp;lt;=n&amp;lt;=30。
    分析：对于正数，直接使用算术右移即可；对于负数，需要加上适当的偏移量以实现向上舍入，这可以用根据符号位生成1个全0或者全1的掩码来控制。
    答案：
    {% codeblock lang:c %}
    int divpwr2(int x, int n) {
    /&lt;em&gt; add bias when x is negative, which is controlled by a sign-related mask &lt;/em&gt;/
        int mask = x &amp;gt;&amp;gt; 31;
        int add = ((1 &amp;lt;&amp;lt; n) + (~1) + 1) &amp;amp; mask;
        return (x + add) &amp;gt;&amp;gt; n;
    }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;negate
    问题：要求使用! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;以及不超过5个操作符求出x的负数。
    分析：-x = (~x + 1)
    答案：
    {% codeblock lang:c %}
    int isPositive(int x) {
    ／&lt;em&gt; -x = (~x) + 1 &lt;/em&gt;／
        return (!(x &amp;gt;&amp;gt; 31)) ^ (!(x ^ 0));
    }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;isPositive
    问题：要求使用! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;以及不超过8个操作符判断x是否为正数。
    分析：对于正数，它的最高位一定是0，同时还要排除0的影响。
    答案：
    {% codeblock lang:c %}
    int isPositive(int x) {
    /&lt;em&gt; ensure the highest bit is 0 and x != 0 &lt;/em&gt;/
        return (!(x &amp;gt;&amp;gt; 31)) ^ (!(x ^ 0));
    }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;isLessOrEqual
    问题：要求使用! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;以及不超过24个操作符判断x是否小于或等于y。
    分析：
    对于这个问题，我们需要按照是否溢出，以及x与y的符号分别讨论。
    最基本的思路是，做y-x，若结果的符号位为1，则返回0，反之返回1。但这样就忽略了溢出可能导致的问题，现在我们做如下考虑。
    若x，y均为正数，或x，y均为负数，则y-x绝不可能溢出，因此可直接用差的符号位判断大小。
    若x为正数，y为负数，可以直接返回0。
    若x为负数，y为正数，可以直接返回1。
    我们可以生成两种条件变量，一种为x，y同号时返回正确结果的条件变量，另一种为x，y异号时返回正确结果的条件变量。
    对于x，y同号和异号这两种不同的情况，我们可以用!((x ^ y) &amp;gt;&amp;gt; 31)生成掩码使得在任意的情况下，只有正确的条件变量生效。
    答案：
    {% codeblock lang:c %}
    int isLessOrEqual(int x, int y) {
    /&lt;em&gt; different processing ways when x and y have the same signs or different signs &lt;/em&gt;/
        int diff = y + (~x) + 1;
        int not_diff_sign = !(diff &amp;gt;&amp;gt; 31);
        int mask = !((x ^ y) &amp;gt;&amp;gt; 31);
        int result_not_overflow = mask &amp;amp; not_diff_sign;
        int result_overflow = (!mask) &amp;amp; (x &amp;gt;&amp;gt; 31);
        return result_overflow | result_not_overflow;
    }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;ilog2
    问题：要求使用! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;以及不超过90个操作数求出x以2为底的对数（向下舍入），保证x&amp;gt;0。
    分析：
    这道题参考了网上的答案。核心的思想是二分查找。
    首先将x右移16位，如果x&amp;gt;0，则表明结果的第5位为1，将该位置为1。
    然后根据结果将x右移8位（第5位为0）或者将x右移24位（第5位为1），如果x&amp;gt;0，则表明结果的第4位为1，将该位置为1。
    以此类推，直到得出结果。
    答案：
    {% codeblock lang:c %}
    int ilog2(int x) {
        /&lt;em&gt; Binary Search &lt;/em&gt;/
        int result = (!!(x &amp;gt;&amp;gt; 16) &amp;lt;&amp;lt; 4);
        result = result + ((!!(x &amp;gt;&amp;gt; (result + 8))) &amp;lt;&amp;lt; 3);
        result = result + ((!!(x &amp;gt;&amp;gt; (result + 4))) &amp;lt;&amp;lt; 2);
        result = result + ((!!(x &amp;gt;&amp;gt; (result + 2))) &amp;lt;&amp;lt; 1);
        result = result + (!!(x &amp;gt;&amp;gt; (result + 1)));
        return result;
    }&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第三部分 浮点数操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;float_neg
    问题：返回对于浮点数参数f，-f的等价的位级表示。当参数位NAN时，返回NAN。函数的参数和返回值均为unsigned，但它们实际上都是浮点数的位表示。最多允许使用10个操作符。
    分析：首先要判断参数是否是NAN，如果是则直接返回，否的话直接将参数的最高位取反即可。
    NAN的阶码全为1，尾码不全为0。
    答案：
    {% codeblock lang:c %}
    unsigned float_neg(unsigned uf) {
    /&lt;em&gt; m_flag - if m != 0 e_flag - if e == 0xff &lt;/em&gt;/
        unsigned m_flag = 0x007fffff &amp;amp; uf;
        unsigned e_flag = !(0x7f800000 &amp;amp; (~uf));
        if (e_flag &amp;amp;&amp;amp; m_flag) {
            return uf;
        } else {
            return 0x80000000 ^ uf;
        }
    }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;float_i2f
    问题：返回(float)x的位级的等价表示。结果被作为unsigned int返回，但它实际上是单精度浮点数的位表示。最多允许使用30个操作符。
    分析：
    首先考虑到整数中只有0会被转换为非规格化浮点数，而其他整数会被转化为规格化浮点数。因此对于0需要做额外的处理。
    其次，对于负数，我们需要将其转化为正数再做处理，这就要求我们需要将x的符号保存下来，并且从补码转化为无符号表示。
    然后，我们需要根据转换成无符号数的x算出阶码e和尾码m。
    最后，我们将尾码舍入后再和阶码符号一起，生成最终的结果即可。
    这里我有一个比较大的误区，舍入的时候看的不仅仅是带舍入位的下一位，而是待舍入位之后的所有位。
    答案：
    {% codeblock lang:c %}
    unsigned float_i2f(int x) {
    /&lt;em&gt; 1.process 0 individually 2.process negative number and store the sign 3.get the e number 4.get the m number and round it 5.construct the result &lt;/em&gt;/
        unsigned count = 0;
        unsigned mask = 0x80000000;
        unsigned sign = x &amp;amp; mask;
        unsigned c = 0, absx = x;
        if (x == 0) {
            return 0;
        } else {
            if (x &amp;lt; 0) {
                absx = -x;
            }
            while (!(mask &amp;amp; absx)) {
                count = count + 1;
                mask = mask &amp;gt;&amp;gt; 1;
            }
            absx = absx &amp;lt;&amp;lt; (count + 1);
            if (((absx &amp;amp; 0x1ff) &amp;gt; 0x100) || ((absx &amp;amp; 0x3ff) &amp;gt;= 0x300)) {
                c = 1;
            }
            return sign + ((158 - count) &amp;lt;&amp;lt; 23) + (absx &amp;gt;&amp;gt; 9)+ c;
        }
    }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;float_twice
    问题：返回对于浮点数参数f，2&lt;em&gt;f的等价的位级表示。参数和结果都为unsigned int，但它们实际上是浮点数的位表示。当参数是NAN时，返回NAN。最多允许使用30个操作符。
    分析：
    对于非规格化浮点数，只要在保留符号位的情况下将尾码m右移一位即可，这样同时解决了尾码乘以二和进位的情况。
    对于规格化浮点数，只要将其阶码e加1即可。
    答案：
    {% codeblock lang:c %}
    unsigned float_twice(unsigned uf) {
    /&lt;/em&gt; denormailized number - m = m &amp;lt;&amp;lt; 1 normalized number - e = e + 1 */
        unsigned result = uf;
        if ((uf &amp;amp; 0x7f800000) == 0) {
            result = ((uf &amp;amp; 0x007fffff) &amp;lt;&amp;lt; 1) | (uf &amp;amp; 0x80000000);
        } else if ((uf &amp;amp; 0x7f800000) != 0x7f800000) {
            result = uf + 0x00800000;
        }
        return result;
    }&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="计算机系统"></category><category term="实验"></category></entry><entry><title>Android PropertyAnimation 属性动画（二）弹跳小球实例</title><link href="/android-propertyanimation-shu-xing-dong-hua-er-dan-tiao-xiao-qiu-shi-li.html" rel="alternate"></link><published>2017-04-02T10:08:31+08:00</published><updated>2017-04-02T10:08:31+08:00</updated><author><name>Di Wu</name></author><id>tag:None,2017-04-02:/android-propertyanimation-shu-xing-dong-hua-er-dan-tiao-xiao-qiu-shi-li.html</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/viseator/AndroidAnimatorBounceBallDemo"&gt;GitHub完整代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.viseator.com/2017/03/26/android_property_animation_1/"&gt;上篇博客&lt;/a&gt;简单介绍了属性动画的原理，这篇博客将会以一个简单的实例来运用上之前讲的内容，并对&lt;code&gt;Animator&lt;/code&gt;的几个回调方法进行讲解。&lt;/p&gt;
&lt;p&gt;目标是自定义一个&lt;code&gt;View&lt;/code&gt;，在画布上绘制一个小球，点击屏幕后小球从顶部自由下落，落到底边后反弹，反弹损失一半的能量，也就是说小球只能上升到下落时一半的高度，再重复这个过程直到退出程序。如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/images/android_animator.gif"&gt;&lt;/p&gt;
&lt;!--more--&gt;

&lt;h2&gt;创建自定义View&lt;/h2&gt;
&lt;p&gt;首先我们要创建一个自定义&lt;code&gt;View&lt;/code&gt;，这里我就采用继承&lt;code&gt;LinearLayout&lt;/code&gt;的方式来创建这个&lt;code&gt;View&lt;/code&gt;，但要注意&lt;code&gt;LinearLayout&lt;/code&gt;默认是不绘制自身的，需要在&lt;code&gt;onDraw()&lt;/code&gt;方法之前适当的时候调用&lt;code&gt;setWillNotDraw(false);&lt;/code&gt;令其进行绘制。&lt;/p&gt;
&lt;p&gt;在继承&lt;code&gt;LinearLayout&lt;/code&gt;的同时我们要实现全部三个构造方法，否则xml文件的预览解析会出现问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;VView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;VView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AttributeSet&lt;/span&gt; &lt;span class="n"&gt;attrs&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;super …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/viseator/AndroidAnimatorBounceBallDemo"&gt;GitHub完整代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.viseator.com/2017/03/26/android_property_animation_1/"&gt;上篇博客&lt;/a&gt;简单介绍了属性动画的原理，这篇博客将会以一个简单的实例来运用上之前讲的内容，并对&lt;code&gt;Animator&lt;/code&gt;的几个回调方法进行讲解。&lt;/p&gt;
&lt;p&gt;目标是自定义一个&lt;code&gt;View&lt;/code&gt;，在画布上绘制一个小球，点击屏幕后小球从顶部自由下落，落到底边后反弹，反弹损失一半的能量，也就是说小球只能上升到下落时一半的高度，再重复这个过程直到退出程序。如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/images/android_animator.gif"&gt;&lt;/p&gt;
&lt;!--more--&gt;

&lt;h2&gt;创建自定义View&lt;/h2&gt;
&lt;p&gt;首先我们要创建一个自定义&lt;code&gt;View&lt;/code&gt;，这里我就采用继承&lt;code&gt;LinearLayout&lt;/code&gt;的方式来创建这个&lt;code&gt;View&lt;/code&gt;，但要注意&lt;code&gt;LinearLayout&lt;/code&gt;默认是不绘制自身的，需要在&lt;code&gt;onDraw()&lt;/code&gt;方法之前适当的时候调用&lt;code&gt;setWillNotDraw(false);&lt;/code&gt;令其进行绘制。&lt;/p&gt;
&lt;p&gt;在继承&lt;code&gt;LinearLayout&lt;/code&gt;的同时我们要实现全部三个构造方法，否则xml文件的预览解析会出现问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;VView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;VView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AttributeSet&lt;/span&gt; &lt;span class="n"&gt;attrs&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;attrs&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;VView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AttributeSet&lt;/span&gt; &lt;span class="n"&gt;attrs&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;defStyleAttr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;attrs&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;defStyleAttr&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;创建好自定义&lt;code&gt;View&lt;/code&gt;后，我们就可以在对应的layout xml布局文件中用完整包名+类名的方式使用我们的自定义&lt;code&gt;View&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;com.viseator.viewtest.VView&lt;/span&gt;
    &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;match_parent&amp;quot;&lt;/span&gt;
    &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;match_parent&amp;quot;&lt;/span&gt;
    &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同时，我们在绘制之前的&lt;code&gt;onMeasure()&lt;/code&gt;方法中调用&lt;code&gt;setWillNotDraw(false);&lt;/code&gt;使自定义&lt;code&gt;View&lt;/code&gt;可以绘制：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onMeasure&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;widthMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;heightMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;setWillNotDraw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;setOnClickListener&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onMeasure&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;widthMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;heightMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里也调用了&lt;code&gt;setOnClickListener()&lt;/code&gt;注册之后的点击事件。&lt;/p&gt;
&lt;h2&gt;绘制&lt;/h2&gt;
&lt;h3&gt;小球的绘制&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;ValueAnimator&lt;/span&gt; &lt;span class="n"&gt;animator&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;xPos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;yPos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Paint&lt;/span&gt; &lt;span class="n"&gt;paint&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Paint&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onDraw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Canvas&lt;/span&gt; &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onDraw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;animator&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;canvasHeight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getHeight&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;         
        &lt;span class="n"&gt;paint&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setColor&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getResources&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getColor&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;color&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Gray&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;paint&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAntiAlias&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;drawCircle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;drawCircle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Canvas&lt;/span&gt; &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;drawCircle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xPos&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;yPos&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;paint&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里第10行对是否是第一次绘制进行判断并将画布大小保存到&lt;code&gt;canvasHeight&lt;/code&gt;供之后的绘制使用（之后的绘制的坐标需要相对于画布的坐标）并设置&lt;code&gt;paint&lt;/code&gt;的属性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;drawCircle()&lt;/code&gt;方法也非常简单，只是调用&lt;code&gt;canvas&lt;/code&gt;提供的&lt;code&gt;drawCircle()&lt;/code&gt;方法指定位置与半径和之前设置的&lt;code&gt;paint&lt;/code&gt;，调用后就会在屏幕上的对应位置绘制一个小球。&lt;/p&gt;
&lt;h3&gt;下落动画的绘制&lt;/h3&gt;
&lt;p&gt;下面就要让小球“动”起来，其实并不是小球发生了移动，只是我们不停地改变小球绘制的位置，当绘制的速率（帧率）大于24帧时的，就在视觉上变成了流畅的动画。也就是说，我们需要使用&lt;code&gt;Animator&lt;/code&gt;连续地改变小球的位置，为了实现加速的效果，位置的改变速率应该随时间增加，也就是需要我们上一篇博客提到的&lt;code&gt;Evaluator&lt;/code&gt;来实现。&lt;/p&gt;
&lt;h4&gt;animator的初始化&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;init&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;animator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ValueAnimator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ofInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;animator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setDuration&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;animator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setRepeatCount&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ValueAnimator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;INFINITE&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;animator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setRepeatMode&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ValueAnimator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;RESTART&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;animator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setInterpolator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;AccelerateInterpolator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rate&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;animator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addUpdateListener&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;animator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addListener&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;写成一个初始化方法便于重新初始化。&lt;/p&gt;
&lt;p&gt;第2行将传入的值区间的开始与结束值作为参数获得了一个值为&lt;code&gt;int&lt;/code&gt;的&lt;code&gt;ValueAnimator&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第3行设置了动画的时间为1秒。&lt;/p&gt;
&lt;p&gt;第4、5行分别设置了动画的重复次数为无限次，重复模式为重新开始，顾名思义，动画可以重复进行，重新开始的重复模式意味着一次动画结束之后数值重新从&lt;code&gt;start&lt;/code&gt;到&lt;code&gt;end&lt;/code&gt;进行改变，也可以设置重复的模式为反向，即一次动画结束之后数值从&lt;code&gt;end&lt;/code&gt;到&lt;code&gt;start&lt;/code&gt;变化。&lt;/p&gt;
&lt;p&gt;第六行为&lt;code&gt;animator&lt;/code&gt;设置了一个库中提供的&lt;code&gt;AccelerateInterpolator&lt;/code&gt;即加速插值器，这就是我们实现加速效果的关键，上篇之中已经看过它的源码，默认时返回的最终动画进行百分比是时间百分比的平方，达到了位置随着时间的平方变化，也就是实现了加速下落的效果。&lt;/p&gt;
&lt;p&gt;第7、8两行分别为&lt;code&gt;animator&lt;/code&gt;设置了一个&lt;code&gt;UpdateListener&lt;/code&gt;用于监听数值变化，一个&lt;code&gt;Listener&lt;/code&gt;用于监听&lt;code&gt;animator&lt;/code&gt;本身开始、停止、重复。&lt;/p&gt;
&lt;h4&gt;完成下落动画&lt;/h4&gt;
&lt;p&gt;创建好了&lt;code&gt;ValueAnimator&lt;/code&gt;，下一步就是在适合的时候在画布上重新绘制位置参数被&lt;code&gt;animator&lt;/code&gt;改变后的小球。注意到我们之前小球的y坐标存储在&lt;code&gt;yPos&lt;/code&gt;变量中，我们只要适时令&lt;code&gt;yPos&lt;/code&gt;等于改变后的值再通过&lt;code&gt;invalidate()&lt;/code&gt;方法进入&lt;code&gt;onDraw()&lt;/code&gt;方法让&lt;code&gt;View&lt;/code&gt;按小球的参数重新进行绘制就可以了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;animator&lt;/code&gt;的&lt;code&gt;ValueAnimator.AnimatorUpdateListener&lt;/code&gt;为我们提供了一个及时刷新&lt;code&gt;View&lt;/code&gt;的时机，之前为&lt;code&gt;animator&lt;/code&gt;注册一个&lt;code&gt;UpdateListener&lt;/code&gt;之后，每当&lt;code&gt;animator&lt;/code&gt;的值发生改变时，&lt;code&gt;onAniamtionUpdate()&lt;/code&gt;就会被回调。&lt;/p&gt;
&lt;p&gt;那我们就可以在这个回调方法中为&lt;code&gt;yPos&lt;/code&gt;设置新的值并令&lt;code&gt;View&lt;/code&gt;重新绘制：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onAnimationUpdate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ValueAnimator&lt;/span&gt; &lt;span class="n"&gt;animation&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;yPos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;animation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getAnimatedValue&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;invalidate&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，我们只要启动&lt;code&gt;animator&lt;/code&gt;令它的值开始变化，就会不断地调用&lt;code&gt;onAnimationUpdate()&lt;/code&gt;重绘&lt;code&gt;View&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onClick&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;canvasHeight&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;animationHeight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;canvasHeight&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;animator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;start()&lt;/code&gt;方法令&lt;code&gt;animator&lt;/code&gt;开始。&lt;/p&gt;
&lt;p&gt;到这里，我们已经可以看到点击屏幕后小球下落到底部并停止的效果。&lt;/p&gt;
&lt;h3&gt;回弹效果实现&lt;/h3&gt;
&lt;p&gt;我们之前已经为&lt;code&gt;animator&lt;/code&gt;设置了无限重复，并且模式为重新开始，那么要做到回弹的效果，就要在小球落到底边（动画完成）之后，为小球设置新的初始值与最终值，让小球从最低点回到落下时一半的高度。高度数据我们在&lt;code&gt;onClick()&lt;/code&gt;中的第4行（上面代码）已经初始化为了相对于画布的高度，之后再使用时只需把它除2就可以表示圆心距底边的高度了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Animator.AnimatorListener&lt;/code&gt;为我们提供了一系列方法用于监听&lt;code&gt;animator&lt;/code&gt;状态的变化（而不是数值）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/images/AnimatorListener.jpg"&gt;&lt;/p&gt;
&lt;p&gt;（除金色为Android 8新增外），依次为动画取消，动画结束，动画开始重复，动画开始。&lt;/p&gt;
&lt;p&gt;这里我们就需要在&lt;code&gt;onAnimationReapt()&lt;/code&gt;回调中为动画设置新的初值与结束数值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onAnimationRepeat&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Animator&lt;/span&gt; &lt;span class="n"&gt;animation&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ValueAnimator&lt;/span&gt; &lt;span class="n"&gt;vAnimation&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ValueAnimator&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;animation&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isDown&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;animationHeight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;animationHeight&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;isDown&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;isDown&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isDown&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;vAnimation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setIntValues&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;canvasHeight&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;animationHeight&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;canvasHeight&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;vAnimation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setInterpolator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;AccelerateInterpolator&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;vAnimation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setIntValues&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;canvasHeight&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;canvasHeight&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;animationHeight&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;vAnimation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setInterpolator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;DecelerateInterpolator&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;回调参数中的&lt;code&gt;animation&lt;/code&gt;就是回调这个函数的&lt;code&gt;animator&lt;/code&gt;，第3行对其进行一个类型转换。&lt;/p&gt;
&lt;p&gt;这里我们使用了一个&lt;code&gt;isDown&lt;/code&gt;参数来判断是否是下落过程，如果上个动画是下落过程，就将&lt;code&gt;animationHeight&lt;/code&gt;减半。&lt;/p&gt;
&lt;p&gt;第7行把&lt;code&gt;isDown&lt;/code&gt;置反，再根据&lt;code&gt;isDown&lt;/code&gt;的判断使用&lt;code&gt;setIntValues()&lt;/code&gt;方法为&lt;code&gt;animator&lt;/code&gt;设置新的范围，使用&lt;code&gt;setInterpolator()&lt;/code&gt;方法设置新的插值器，注意上升时使用的应该是&lt;code&gt;DecelerateInterpolater&lt;/code&gt;减速上升。&lt;/p&gt;
&lt;p&gt;这样在新的动画开始时属性改变的范围就得到了改变，也就使得小球可以反弹了。&lt;/p&gt;
&lt;p&gt;为了让每一次点击时动画都可以重新开始，在&lt;code&gt;onClick()&lt;/code&gt;方法中加入几行初始化代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onClick&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;animator&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;animator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;end&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;canvasHeight&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;animationHeight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;canvasHeight&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;isDown&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;animator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里第3-5行让如果存在的&lt;code&gt;animator&lt;/code&gt;停止，否则新动画无法启动。&lt;/p&gt;
&lt;p&gt;下篇博客将会从源码角度继续探索&lt;code&gt;animator&lt;/code&gt;的实现原理和更高级的一些特性。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/viseator/AndroidAnimatorBounceBallDemo"&gt;GitHub完整代码&lt;/a&gt;&lt;/p&gt;</content><category term="Android"></category><category term="UI"></category><category term="Animation"></category></entry><entry><title>设计模式——创建型模式</title><link href="/she-ji-mo-shi-chuang-jian-xing-mo-shi.html" rel="alternate"></link><published>2017-03-20T12:56:00+08:00</published><updated>2017-03-20T12:56:00+08:00</updated><author><name>Yifeng Tang</name></author><id>tag:None,2017-03-20:/she-ji-mo-shi-chuang-jian-xing-mo-shi.html</id><summary type="html">&lt;h1&gt;Abstract Factory（抽象工厂）&lt;/h1&gt;
&lt;h2&gt;目标&lt;/h2&gt;
&lt;p&gt;提供一个无需指定的类而可以创建一系列相关的对象的接口。&lt;/p&gt;
&lt;h2&gt;结构&lt;/h2&gt;
&lt;p&gt;&lt;img alt="抽象工厂" src="/images/2017_3_7_1.jpeg"&gt;&lt;/p&gt;
&lt;p&gt;由一个Abstract Factory类派生出多个子类工厂，子类工厂将会提供相应的创建产品的方法。对于客户来说，只需要获得Abstract Factory类中的接口就可以实现各类产品的创建。（与工厂方法有一点区别在抽象工厂一般是生成一系列相互有关系的产品，工厂模式方法一般就是生成某一个产品）&lt;/p&gt;
&lt;h2&gt;使用情形&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一个系统要独立于它的产品的创建、组合和表示时；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个系统要由多个产品系列的一个来配置时；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你强调一系列相关产品对象的设计以便联合使用的时候；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你提供一个产品类库，而只想显示他们的接口而不是实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;参与成员&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AbstractFactory&lt;/p&gt;
&lt;p&gt;声明创建抽象产品对象的操作接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ConcreteFactory&lt;/p&gt;
&lt;p&gt;实现创建具体产品对象的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AbstractProduct&lt;/p&gt;
&lt;p&gt;为一类产品对象声明一个接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ConcreteProduct&lt;/p&gt;
&lt;p&gt;将被具体工厂实现的具体产品对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Client&lt;/p&gt;
&lt;p&gt;使用Abstract接口的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;效果&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;分离了具体的类，提高解耦度。&lt;/p&gt;
&lt;p&gt;它将客户与类的实现分离开，客户通过手中有的抽象工厂接口操纵。产品的类名也在具体工厂的实现中分离，不会出现在客户代码中。客户不必知道自己到底获得了怎样实现的一个类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;易于改变产品的系列。&lt;/p&gt;
&lt;p&gt;由于具体的工厂方法只会在初始化的时候出现一次，所以想要改变产品的系列只需要转换到相应的工厂对象，就可以重新创建一系列的产品。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有利于产品的一致性。&lt;/p&gt;
&lt;p&gt;当一个系列的产品对象被设计成一起工作或者一个应用只能使用一个系列的产品的时候，抽象工厂就可以很轻易地实现这一个功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;难以支持新的产品（或者说功能？）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;代码实例 …&lt;/h2&gt;</summary><content type="html">&lt;h1&gt;Abstract Factory（抽象工厂）&lt;/h1&gt;
&lt;h2&gt;目标&lt;/h2&gt;
&lt;p&gt;提供一个无需指定的类而可以创建一系列相关的对象的接口。&lt;/p&gt;
&lt;h2&gt;结构&lt;/h2&gt;
&lt;p&gt;&lt;img alt="抽象工厂" src="/images/2017_3_7_1.jpeg"&gt;&lt;/p&gt;
&lt;p&gt;由一个Abstract Factory类派生出多个子类工厂，子类工厂将会提供相应的创建产品的方法。对于客户来说，只需要获得Abstract Factory类中的接口就可以实现各类产品的创建。（与工厂方法有一点区别在抽象工厂一般是生成一系列相互有关系的产品，工厂模式方法一般就是生成某一个产品）&lt;/p&gt;
&lt;h2&gt;使用情形&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一个系统要独立于它的产品的创建、组合和表示时；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个系统要由多个产品系列的一个来配置时；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你强调一系列相关产品对象的设计以便联合使用的时候；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你提供一个产品类库，而只想显示他们的接口而不是实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;参与成员&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AbstractFactory&lt;/p&gt;
&lt;p&gt;声明创建抽象产品对象的操作接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ConcreteFactory&lt;/p&gt;
&lt;p&gt;实现创建具体产品对象的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AbstractProduct&lt;/p&gt;
&lt;p&gt;为一类产品对象声明一个接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ConcreteProduct&lt;/p&gt;
&lt;p&gt;将被具体工厂实现的具体产品对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Client&lt;/p&gt;
&lt;p&gt;使用Abstract接口的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;效果&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;分离了具体的类，提高解耦度。&lt;/p&gt;
&lt;p&gt;它将客户与类的实现分离开，客户通过手中有的抽象工厂接口操纵。产品的类名也在具体工厂的实现中分离，不会出现在客户代码中。客户不必知道自己到底获得了怎样实现的一个类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;易于改变产品的系列。&lt;/p&gt;
&lt;p&gt;由于具体的工厂方法只会在初始化的时候出现一次，所以想要改变产品的系列只需要转换到相应的工厂对象，就可以重新创建一系列的产品。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有利于产品的一致性。&lt;/p&gt;
&lt;p&gt;当一个系列的产品对象被设计成一起工作或者一个应用只能使用一个系列的产品的时候，抽象工厂就可以很轻易地实现这一个功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;难以支持新的产品（或者说功能？）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;代码实例&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;AbstractFactory&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Car&lt;/span&gt; &lt;span class="nf"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Cushion&lt;/span&gt; &lt;span class="nf"&gt;makeCushion&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BenzFactory&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;AbstractFactory&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="n"&gt;Benz&lt;/span&gt; &lt;span class="nf"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="n"&gt;BenzCushion&lt;/span&gt; &lt;span class="nf"&gt;makeCushion&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AudiFactory&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;AbstractFactory&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="n"&gt;Audi&lt;/span&gt; &lt;span class="nf"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="n"&gt;AudiCushion&lt;/span&gt; &lt;span class="nf"&gt;makeCushion&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Client&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;AbstractFactory&lt;/span&gt; &lt;span class="n"&gt;factoryA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;BenzFactory&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;AbstractFactory&lt;/span&gt; &lt;span class="n"&gt;factoryB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;AudiFactory&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Car&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;factoryA&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Cushion&lt;/span&gt; &lt;span class="n"&gt;cushionA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;factoryA&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;makeCushion&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Car&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;factoryB&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Cushion&lt;/span&gt; &lt;span class="n"&gt;cushionB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;factoryB&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;makeCushion&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addCushion&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cushionA&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addCushion&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cushionB&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Factory Method（工厂方法）&lt;/h1&gt;
&lt;h2&gt;目标&lt;/h2&gt;
&lt;p&gt;定义一个用于创建对象的接口，让子类决定实例化哪一个类。将实例化延迟到其子类。&lt;/p&gt;
&lt;h2&gt;结构&lt;/h2&gt;
&lt;p&gt;&lt;img alt="结构图" src="/images/2017_3_9_1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;工厂方法被自己的子类所重定义以决定创建哪一个产品对象。&lt;/p&gt;
&lt;h2&gt;协作&lt;/h2&gt;
&lt;p&gt;&lt;img alt="时序图" src="/images/2017_3_9_2.jpg"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用户创建一个工厂；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工厂生产一个产品；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户直接使用或者调用产品的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;适用情形&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当一个类不知道它所必需创建的对象的类的时候；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当一个类希望由它的子类来制定它所创建的对象的时候；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当类创建对象的职责委托给多个子类中的一个，并且你希望选择某个子类使得具体产品明确化的时候。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;参与者&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Product&lt;/p&gt;
&lt;p&gt;定义工厂方法所创建的对象的接口；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ConcreteProduct&lt;/p&gt;
&lt;p&gt;实现Product的接口；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Creator&lt;/p&gt;
&lt;p&gt;声明工厂方法，定义一个具体工厂来生产产品，并且调用工厂方法以返回一个Product；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ConcreteCreator&lt;/p&gt;
&lt;p&gt;重定义一个具体的工厂方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;效果&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将与特定相关产品的代码与你的代码分离，你只需要关心product而不是用户可能会实现出来的各种concreteProduct；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为子类提供了一个hook，这个hook可以帮助提供对象的扩展版本。例如，有一个汽车工厂，该工厂可以生产小汽车，后来这个工厂老板又去开了一家高级汽车厂。这时候，这个汽车厂既可以用原来的方法生产普通汽车，也可以继承之后生产生产高级汽车，此时父类工厂方法已不是一个抽象的方法，而是一个default方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接平行的类层次。当一个类将自己的某些功能委托给另一个独立的类的时候，便产生了平行的类层次。例如，有一个类用于判定学生的试卷得分多少，但是最后这个分数将不会存储在自己身上，而是在另一个类之中。此时，这个分数就是从判定分数的类中的工厂方法中生产的，这样就实现了平行的分层。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;与抽象工厂模式的异同&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;异：&lt;/p&gt;
&lt;p&gt;对于一个抽象工厂模式，它更加倾向于强调一系列产品的生产以及调整改变产品系列；对于工厂方法，仅是为了某一个产品的生产。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同&lt;/p&gt;
&lt;p&gt;实际上在某种方面来说，抽象工厂模式囊括了工厂方法。也就是说抽象工厂方法可以用工厂方法来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码实例&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;AbstractFactory&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Car&lt;/span&gt; &lt;span class="nf"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BenzFactory&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;AbstractFactory&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="n"&gt;Benz&lt;/span&gt; &lt;span class="nf"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AudiFactory&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;AbstractFactory&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="n"&gt;Audi&lt;/span&gt; &lt;span class="nf"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Client&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;AbstractFactory&lt;/span&gt; &lt;span class="n"&gt;factoryA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;BenzFactory&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;AbstractFactory&lt;/span&gt; &lt;span class="n"&gt;factoryB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;AudiFactory&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Car&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;factoryA&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Car&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;factoryB&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Singletion（单例模式）&lt;/h1&gt;
&lt;h2&gt;目标&lt;/h2&gt;
&lt;p&gt;保证一个类只有一个实例，并且提供一个访问它的全局访问点。&lt;/p&gt;
&lt;h2&gt;结构&lt;/h2&gt;
&lt;p&gt;&lt;img alt="结构图" src="/images/2017_3_20_1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图中反映的是所谓懒汉式单例模式——但需要这样一个对象的时候才开始创建这样的一个对象。相反，还有一种勤劳单例模式，当这个类被加载的时候就会创建这样一个单例对象。&lt;/p&gt;
&lt;h2&gt;协作&lt;/h2&gt;
&lt;p&gt;&lt;img alt="时序图" src="/images/2017_3_20_2.jpg"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当用户需要的时候，向类请求一个对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类如果没有创建这个单例对象，就会创建这个对象并且传递回来，如果类已经创建了这个对象，那么就直接简单地将对象传递回来即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;适用情形&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当类只能有一个实例并且用户将会从一个众所周知的访问点访问它；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当这个唯一实例是通过子类化可扩展的，并且客户应该无须更改代码就能使用一个扩展的实例时。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;参与者&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Singleton&lt;/p&gt;
&lt;p&gt;定义一个Instance操作，并且维护一个自己的唯一实例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;效果&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对唯一实例的受控访问；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缩小名空间（对于java来说不存在命名空间）；&lt;/p&gt;
&lt;p&gt;避免了过多的全部变量的出现，使得命名空间更加精简。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;允许对操作和表示的精化；&lt;/p&gt;
&lt;p&gt;？？？不是很懂书上在说啥（&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以改变成多个可控数目的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Tips&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用单例注册表来进行单例的子类的创建。&lt;/p&gt;
&lt;p&gt;Singleton可以将自己的众多子类存放在某个映射表中，然后以某一个字符串或者其他来进行访问注册。（注册过程可以随意地方实现）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;代码实例&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;abstract&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AbstractFactory&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;HashMap&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AbstractFactory&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;registerMap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;HashMap&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

    &lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="nf"&gt;AbstractFactory&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;AbstractFactory&lt;/span&gt; &lt;span class="nf"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;brand&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;registerMap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;containsKey&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;brand&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;brand&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;benz&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;registerMap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;brand&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BenzFactory&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
                    &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
                &lt;span class="o"&gt;}&lt;/span&gt;
                &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Audi&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;registerMap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;brand&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AudiFactory&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
                    &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
                &lt;span class="o"&gt;}&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;registerMap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;brand&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;abstract&lt;/span&gt; &lt;span class="n"&gt;Car&lt;/span&gt; &lt;span class="nf"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="kd"&gt;abstract&lt;/span&gt; &lt;span class="n"&gt;Cushion&lt;/span&gt; &lt;span class="nf"&gt;makeCushion&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BenzFactory&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;AbstractFactory&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;BenzFactory&lt;/span&gt; &lt;span class="n"&gt;factory&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="nf"&gt;BenzFactory&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;();}&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;BenzFactory&lt;/span&gt; &lt;span class="nf"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;factory&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;factory&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;BenzFactory&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;factory&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="n"&gt;Benz&lt;/span&gt; &lt;span class="nf"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="n"&gt;BenzCushion&lt;/span&gt; &lt;span class="nf"&gt;makeCushion&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AudiFactory&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;AbstractFactory&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;AudiFactory&lt;/span&gt; &lt;span class="n"&gt;factory&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="nf"&gt;AudiFactory&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;();}&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;AudiFactory&lt;/span&gt; &lt;span class="nf"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;factory&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;factory&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;AudiFactory&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;factory&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="n"&gt;Audi&lt;/span&gt; &lt;span class="nf"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="n"&gt;AudiCushion&lt;/span&gt; &lt;span class="nf"&gt;makeCushion&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Client&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;AbstractFactory&lt;/span&gt; &lt;span class="n"&gt;factoryA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;BenzFactory&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;AbstractFactory&lt;/span&gt; &lt;span class="n"&gt;factoryB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;AudiFactory&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Car&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;factoryA&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Cushion&lt;/span&gt; &lt;span class="n"&gt;cushionA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;factoryA&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;makeCushion&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Car&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;factoryB&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;makeCar&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Cushion&lt;/span&gt; &lt;span class="n"&gt;cushionB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;factoryB&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;makeCushion&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addCushion&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cushionA&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addCushion&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cushionB&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Builder（生成器）&lt;/h1&gt;
&lt;h2&gt;目标&lt;/h2&gt;
&lt;p&gt;将一个较为复杂的对象的构建与表示分离，并且能够在多个构建过程之后构建出不同的表示。&lt;/p&gt;
&lt;h2&gt;结构&lt;/h2&gt;
&lt;p&gt;&lt;img alt="结构图" src="/images/2017_3_7_2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;对于一个Builder它将会把生产过程中的产物放在自己这里，按照Director的调用方法的顺序来执行生产，最后有一个返回产物的方法。&lt;/p&gt;
&lt;h2&gt;协作&lt;/h2&gt;
&lt;p&gt;&lt;img alt="时序图" src="/images/2017_3_7_3.jpg"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;客户创建一个Director对象，并且配置相应的Builder；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Builder处理Director的请求，将部件添加到产品中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户从Builder中检索获得产品。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;使用情形&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当构造过程必须允许被构造的对象有不同的表示时。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;参与者&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Builder&lt;/p&gt;
&lt;p&gt;为创建一个Product对象的各个部件制定抽象接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ConcreteBuilder&lt;/p&gt;
&lt;p&gt;实现Builder的接口并且定义明确他所创建的表示，再提供一个检索产品的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Director&lt;/p&gt;
&lt;p&gt;一个使用Builder，指导整个生产过程的一个对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Product&lt;/p&gt;
&lt;p&gt;表示被生产的具体产品。（可以不使用一个抽象类来完成构造）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;实例代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Builder&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;addWheel&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;addEngine&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Car&lt;/span&gt; &lt;span class="nf"&gt;getCar&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BenzBuilder&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Builder&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;addWheel&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;addEngine&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="n"&gt;Benz&lt;/span&gt; &lt;span class="nf"&gt;getCar&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Benz&lt;/span&gt;&lt;span class="o"&gt;();}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Director&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Builder&lt;/span&gt; &lt;span class="n"&gt;builder&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;Director&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Builder&lt;/span&gt; &lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;builder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Car&lt;/span&gt; &lt;span class="nf"&gt;construct&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addWheel&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addEngine&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getCar&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Client&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;BenzBuilder&lt;/span&gt; &lt;span class="n"&gt;builder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;BenzBuilder&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Director&lt;/span&gt; &lt;span class="n"&gt;director&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Director&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Car&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;director&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;construct&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="Design Patterns"></category></entry><entry><title>Android View绘制之layout过程</title><link href="/android-viewhui-zhi-zhi-layoutguo-cheng.html" rel="alternate"></link><published>2017-03-12T14:02:47+08:00</published><updated>2017-03-12T14:02:47+08:00</updated><author><name>Di Wu</name></author><id>tag:None,2017-03-12:/android-viewhui-zhi-zhi-layoutguo-cheng.html</id><summary type="html">&lt;p&gt;经过&lt;a href="http://www.viseator.xyz/2017/03/10/android_view_onMeasure/"&gt;上一篇&lt;/a&gt;介绍的&lt;code&gt;measure&lt;/code&gt;过程之后，各个&lt;code&gt;View&lt;/code&gt;的尺寸信息已经存储在了每个&lt;code&gt;View&lt;/code&gt;中，下面是&lt;code&gt;layout&lt;/code&gt;过程，&lt;code&gt;layout&lt;/code&gt;过程的目的是根据上一步中计算出的尺寸来正确设置各个&lt;code&gt;View&lt;/code&gt;及其后代的位置。这个过程首先被调用的是&lt;code&gt;View&lt;/code&gt;的&lt;code&gt;layout()&lt;/code&gt;方法，&lt;code&gt;layout()&lt;/code&gt;的方法签名是&lt;code&gt;public void layout(int l, int t, int r, int b)&lt;/code&gt;，四个参数分别为左边界距父&lt;code&gt;View&lt;/code&gt;左边界的距离，上边界距父&lt;code&gt;View&lt;/code&gt;上边界的距离，右边界距父&lt;code&gt;View&lt;/code&gt;左边界的距离，下边界距父&lt;code&gt;View&lt;/code&gt;上边界的距离。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;changed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;isLayoutModeOptical …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;经过&lt;a href="http://www.viseator.xyz/2017/03/10/android_view_onMeasure/"&gt;上一篇&lt;/a&gt;介绍的&lt;code&gt;measure&lt;/code&gt;过程之后，各个&lt;code&gt;View&lt;/code&gt;的尺寸信息已经存储在了每个&lt;code&gt;View&lt;/code&gt;中，下面是&lt;code&gt;layout&lt;/code&gt;过程，&lt;code&gt;layout&lt;/code&gt;过程的目的是根据上一步中计算出的尺寸来正确设置各个&lt;code&gt;View&lt;/code&gt;及其后代的位置。这个过程首先被调用的是&lt;code&gt;View&lt;/code&gt;的&lt;code&gt;layout()&lt;/code&gt;方法，&lt;code&gt;layout()&lt;/code&gt;的方法签名是&lt;code&gt;public void layout(int l, int t, int r, int b)&lt;/code&gt;，四个参数分别为左边界距父&lt;code&gt;View&lt;/code&gt;左边界的距离，上边界距父&lt;code&gt;View&lt;/code&gt;上边界的距离，右边界距父&lt;code&gt;View&lt;/code&gt;左边界的距离，下边界距父&lt;code&gt;View&lt;/code&gt;上边界的距离。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;changed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;isLayoutModeOptical&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mParent&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;
        &lt;span class="n"&gt;setOpticalFrame&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;setFrame&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;changed&lt;/code&gt;是用于传递给&lt;code&gt;onLayout()&lt;/code&gt;方法的参数，它指示了布局是否被改变。&lt;/p&gt;
&lt;p&gt;后面的表达式查看了父&lt;code&gt;View&lt;/code&gt;的布局模式是否需要显示边框，如需要，调用的是&lt;code&gt;setOpticalFrame()&lt;/code&gt;方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;setOpticalFrame&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bottom&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Insets&lt;/span&gt; &lt;span class="n"&gt;parentInsets&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mParent&lt;/span&gt; &lt;span class="k"&gt;instanceof&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;
            &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;View&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;mParent&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;getOpticalInsets&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Insets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;NONE&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Insets&lt;/span&gt; &lt;span class="n"&gt;childInsets&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getOpticalInsets&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;setFrame&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;left&lt;/span&gt;   &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;parentInsets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;left&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;childInsets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;left&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;top&lt;/span&gt;    &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;parentInsets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;top&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;childInsets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;top&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;right&lt;/span&gt;  &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;parentInsets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;left&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;childInsets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;right&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;bottom&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;parentInsets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;top&lt;/span&gt;  &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;childInsets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;bottom&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到这个方法读取了设置的边框值， 把原值加上边框值后还是调用了&lt;code&gt;setFrame()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setFrame()&lt;/code&gt;方法通过传入的参数确定了该&lt;code&gt;View&lt;/code&gt;最终的位置以及尺寸。&lt;/p&gt;
&lt;p&gt;可以看到，一个&lt;code&gt;View&lt;/code&gt;最终显示在什么位置以及它的尺寸是由&lt;code&gt;layout()&lt;/code&gt;方法决定的，&lt;code&gt;onMeasure()&lt;/code&gt;方法只是将测量出的&lt;code&gt;View&lt;/code&gt;期望具有的大小储存在&lt;code&gt;View&lt;/code&gt;中。一般情况下，我们会根据储存的这个尺寸来作为设定的依据。&lt;/p&gt;
&lt;p&gt;接下来&lt;code&gt;layout()&lt;/code&gt;方法会调用&lt;code&gt;onLayout()&lt;/code&gt;方法，（如果需要的话）我们需要重写这个方法来调用子&lt;code&gt;View&lt;/code&gt;的&lt;code&gt;layout()&lt;/code&gt;方法。所以决定子&lt;code&gt;View&lt;/code&gt;如何显示的关键步骤就在这里，他们的位置和尺寸完全取决于这里调用它们的&lt;code&gt;layout()&lt;/code&gt;方法时传入的参数。当然一般情况下我们会根据子&lt;code&gt;View&lt;/code&gt;中的测量结果来设置这个值。这里拿&lt;code&gt;FrameLayout&lt;/code&gt;这个需要处理子&lt;code&gt;View&lt;/code&gt;的&lt;code&gt;ViewGroup&lt;/code&gt;实例来举例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onLayout&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;changed&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bottom&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;layoutChildren&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bottom&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt; &lt;span class="cm"&gt;/* no force left gravity */&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;直接调用了&lt;code&gt;layoutChildren()&lt;/code&gt;：（省略部分行）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;layoutChildren&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bottom&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;forceLeftGravity&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getChildCount&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;parentLeft&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPaddingLeftWithForeground&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;parentRight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;getPaddingRightWithForeground&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;parentTop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPaddingTopWithForeground&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;parentBottom&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bottom&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;getPaddingBottomWithForeground&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="n"&gt;child&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getChildAt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;child&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMeasuredWidth&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;child&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMeasuredHeight&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;childLeft&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;childTop&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

            &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;verticalGravity&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;Gravity&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TOP&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;childTop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parentTop&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;lp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;topMargin&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
                    &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;Gravity&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;CENTER_VERTICAL&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;childTop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parentTop&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parentBottom&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;parentTop&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;
                    &lt;span class="n"&gt;lp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;topMargin&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;lp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;bottomMargin&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
                    &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;Gravity&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;BOTTOM&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;childTop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parentBottom&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;lp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;bottomMargin&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
                    &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;childTop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parentTop&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;lp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;topMargin&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;

            &lt;span class="n"&gt;child&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;childLeft&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;childTop&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;childLeft&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;childTop&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;省略了与获取布局属性相关的代码，可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4-8行获取了父&lt;code&gt;View&lt;/code&gt;的位置数据并在18-31行用于确定最终的位置数据&lt;/li&gt;
&lt;li&gt;10-11行遍历了所有的子&lt;code&gt;View&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;12-13行获取了子&lt;code&gt;View&lt;/code&gt;中在上一步骤的测量过程中储存的宽和高，并用于第33行中设置最终的右边界与下边界&lt;/li&gt;
&lt;li&gt;第33行调用子&lt;code&gt;View&lt;/code&gt;的&lt;code&gt;layout()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;</content><category term="Android"></category><category term="View"></category></entry><entry><title>Android View绘制之measure过程</title><link href="/android-viewhui-zhi-zhi-measureguo-cheng.html" rel="alternate"></link><published>2017-03-10T18:30:16+08:00</published><updated>2017-03-10T18:30:16+08:00</updated><author><name>Di Wu</name></author><id>tag:None,2017-03-10:/android-viewhui-zhi-zhi-measureguo-cheng.html</id><summary type="html">&lt;p&gt;&lt;a href="http://www.viseator.xyz/2017/03/09/android_view_lifeCycle/"&gt;上一篇博客&lt;/a&gt;简单地介绍了&lt;code&gt;View&lt;/code&gt;绘制的生命周期， 从这篇博客开始将会对这个周期中一些有用的过程进行一个详细一些的介绍。这篇的主角就是在构造方法之后调用的&lt;code&gt;measure&lt;/code&gt;过程。&lt;/p&gt;
&lt;p&gt;为了演示，继承了&lt;code&gt;TextView&lt;/code&gt;来实现一个自定义的&lt;code&gt;View&lt;/code&gt;。注意这里继承的应该是&lt;code&gt;android.support.v7.widget.AppCompatTextView&lt;/code&gt;这个类。同时为了&lt;code&gt;xml&lt;/code&gt;文件的正常解析，我们需要实现&lt;code&gt;View&lt;/code&gt;的三个构造方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;VView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;VView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AttributeSet&lt;/span&gt; &lt;span class="n"&gt;attrs&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;attrs&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;VView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AttributeSet&lt;/span&gt; &lt;span class="n"&gt;attrs&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;defStyleAttr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;super …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://www.viseator.xyz/2017/03/09/android_view_lifeCycle/"&gt;上一篇博客&lt;/a&gt;简单地介绍了&lt;code&gt;View&lt;/code&gt;绘制的生命周期， 从这篇博客开始将会对这个周期中一些有用的过程进行一个详细一些的介绍。这篇的主角就是在构造方法之后调用的&lt;code&gt;measure&lt;/code&gt;过程。&lt;/p&gt;
&lt;p&gt;为了演示，继承了&lt;code&gt;TextView&lt;/code&gt;来实现一个自定义的&lt;code&gt;View&lt;/code&gt;。注意这里继承的应该是&lt;code&gt;android.support.v7.widget.AppCompatTextView&lt;/code&gt;这个类。同时为了&lt;code&gt;xml&lt;/code&gt;文件的正常解析，我们需要实现&lt;code&gt;View&lt;/code&gt;的三个构造方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;VView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;VView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AttributeSet&lt;/span&gt; &lt;span class="n"&gt;attrs&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;attrs&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;VView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AttributeSet&lt;/span&gt; &lt;span class="n"&gt;attrs&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;defStyleAttr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;attrs&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;defStyleAttr&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再通过完整包名的方法在&lt;code&gt;xml&lt;/code&gt;布局文件中创建我们的&lt;code&gt;View&lt;/code&gt;就可以直接显示了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;com.viseator.viewtest.VView&lt;/span&gt;
    &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;100dp&amp;quot;&lt;/span&gt;
    &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;100dp&amp;quot;&lt;/span&gt;
    &lt;span class="na"&gt;android:background=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@color/Gray&amp;quot;&lt;/span&gt;
    &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里给了&lt;code&gt;TextView&lt;/code&gt;一个背景颜色便于后面的观察。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面就开始分析&lt;code&gt;measure&lt;/code&gt;过程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;measure&lt;/code&gt;是一个自顶向下的过程，即父&lt;code&gt;View&lt;/code&gt;会依次调用它的子&lt;code&gt;View&lt;/code&gt;的&lt;code&gt;measure()&lt;/code&gt;方法来对它的子&lt;code&gt;View&lt;/code&gt;进行测量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;View&lt;/code&gt;的&lt;code&gt;measure()&lt;/code&gt;方法最终会调用&lt;code&gt;onMeasure()&lt;/code&gt;，真正的尺寸信息就是在&lt;code&gt;onMeasure()&lt;/code&gt;方法中最终确定的。所以我们需要做的就是在自定义&lt;code&gt;View&lt;/code&gt;中重写&lt;code&gt;onMeasure()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;那么子&lt;code&gt;View&lt;/code&gt;根据什么来确定自己应该具有的尺寸呢？当然不可能让子&lt;code&gt;View&lt;/code&gt;自由地决定自己的大小，父&lt;code&gt;View&lt;/code&gt;必然需要向子&lt;code&gt;View&lt;/code&gt;传递信息来帮助子&lt;code&gt;View&lt;/code&gt;来确定尺寸，而子&lt;code&gt;View&lt;/code&gt;则必须满足父&lt;code&gt;View&lt;/code&gt;的要求。查看&lt;code&gt;measure()&lt;/code&gt;的方法签名：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;measure&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;widthMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;heightMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的&lt;code&gt;widthMeasureSpec&lt;/code&gt;与&lt;code&gt;heightMeasureSpec&lt;/code&gt;就是存储这一信息的参数。它们的类型是&lt;code&gt;int&lt;/code&gt;，内部以高两位来存储测量的模式，低三十位为测量的大小，计算中使用了位运算来提高并优化效率。当然我们不必使用位运算来获得对应的数值，&lt;code&gt;View.MeasureSpec&lt;/code&gt;为我们提供了对应的方法。&lt;/p&gt;
&lt;p&gt;测量模式有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EXACTLY&lt;/code&gt;：精确值模式，即子&lt;code&gt;View&lt;/code&gt;必须使用这一尺寸，并且保证它们的所有后代都在这个范围之内。当我们将控件的&lt;code&gt;layout_width&lt;/code&gt;、&lt;code&gt;layout_height&lt;/code&gt;属性指定为具体数值或&lt;code&gt;match_parent&lt;/code&gt;时，系统使用这一模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UNSPECIFIED&lt;/code&gt;：无限制模式，不对子&lt;code&gt;View&lt;/code&gt;施加任何限制，完全由子&lt;code&gt;View&lt;/code&gt;决定自己的大小。可以用于查看子&lt;code&gt;View&lt;/code&gt;想要的尺寸，比如可以把子&lt;code&gt;View&lt;/code&gt;的长度使用&lt;code&gt;EXACTLY&lt;/code&gt;模式限制在100，不限制宽度来查看子&lt;code&gt;View&lt;/code&gt;在长度为100情况想要的宽度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AT_MOST&lt;/code&gt;：最大值模式，只限制子&lt;code&gt;View&lt;/code&gt;能具有的最大尺寸，子&lt;code&gt;View&lt;/code&gt;必须保证它和它的后代们都在这一范围之内。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;了解这些，我们就可以通过重写&lt;code&gt;onMeasure()&lt;/code&gt;来确定一个&lt;code&gt;View&lt;/code&gt;的尺寸。&lt;/p&gt;
&lt;p&gt;但在重写方法时要注意：必须调用&lt;code&gt;setMeasuredDimension()&lt;/code&gt; 来将最终尺寸存储在&lt;code&gt;View&lt;/code&gt;中，否则会抛出一个&lt;code&gt;IllegalStateException&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xml&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;com.viseator.viewtest.VView&lt;/span&gt;
    &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
    &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;100dp&amp;quot;&lt;/span&gt;
    &lt;span class="na"&gt;android:background=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@color/Gray&amp;quot;&lt;/span&gt;
    &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;VView&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onMeasure&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;widthMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;heightMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;widthMode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MeasureSpec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMode&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;widthMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;heightMode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MeasureSpec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMode&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heightMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MeasureSpec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;widthMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MeasureSpec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heightMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;d&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TAG&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;widthMode: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;widthMode&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;d&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TAG&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;heightMode: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;heightMode&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;d&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TAG&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;width :&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;d&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TAG&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;height :&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onMeasure&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;widthMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;heightMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;log:&lt;/p&gt;
&lt;p&gt;&lt;img alt="output" src="/images/onMeasureOutput1.png"&gt;&lt;/p&gt;
&lt;p&gt;这段简单的代码验证了之前的说法，分别对宽高设置了&lt;code&gt;wrap_content&lt;/code&gt;和固定值，可以发现模式分别为&lt;code&gt;AT_MOST&lt;/code&gt;与&lt;code&gt;EXACTLY&lt;/code&gt;（以数值表示）。&lt;/p&gt;
&lt;p&gt;这里输出的宽高值是以像素为单位的，可以看到高度的期望值就是设置的大小，但&lt;code&gt;wrap_content&lt;/code&gt;期望的宽度值为1080（屏幕宽度），默认即为屏幕宽度，但最终计算得出的宽度值由于里面没有文字所以为0。&lt;/p&gt;
&lt;p&gt;同样地，&lt;code&gt;UNSPECIFIED&lt;/code&gt;模式给出的默认尺寸也是屏幕的宽/高。&lt;/p&gt;
&lt;p&gt;所以我们可以看到如果想要实现&lt;code&gt;wrap_content&lt;/code&gt;的效果，我们必须在&lt;code&gt;onMeasure&lt;/code&gt;中对&lt;code&gt;AT_MOST&lt;/code&gt;模式计算其内容宽/高并作为最终的宽/高，否则将以屏幕的宽/高进行填充。以&lt;code&gt;LinearLayout&lt;/code&gt;的源码为例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;useLargestChild&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heightMode&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MeasureSpec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;AT_MOST&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;heightMode&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MeasureSpec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UNSPECIFIED&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;mTotalLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="n"&gt;child&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getVirtualChildAt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;child&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;mTotalLength&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;measureNullChild&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;child&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getVisibility&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;GONE&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;getChildrenSkipCount&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;child&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;

        &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;LinearLayout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;LayoutParams&lt;/span&gt; &lt;span class="n"&gt;lp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LinearLayout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;LayoutParams&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;child&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getLayoutParams&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="c1"&gt;// Account for negative margins&lt;/span&gt;
        &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;totalLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mTotalLength&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;mTotalLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;max&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;totalLength&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;totalLength&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;largestChildHeight&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;
                &lt;span class="n"&gt;lp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;topMargin&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;lp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;bottomMargin&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;getNextLocationOffset&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;child&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Add in our padding&lt;/span&gt;
&lt;span class="n"&gt;mTotalLength&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;mPaddingTop&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;mPaddingBottom&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;heightSize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mTotalLength&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这部分代码向我们展示了&lt;code&gt;LinearLayout&lt;/code&gt;处理子&lt;code&gt;View&lt;/code&gt;并计算所有的高度的情况。&lt;/p&gt;
&lt;p&gt;知道了这个调用过程，我们就可以真正地进行&lt;code&gt;onMeasure()&lt;/code&gt;的重写了。&lt;/p&gt;
&lt;p&gt;例如可以暴力指定&lt;code&gt;View&lt;/code&gt;尺寸：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onMeasure&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;widthMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;heightMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;setMeasuredDimension&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;600&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以为&lt;code&gt;AT_MOST&lt;/code&gt;与&lt;code&gt;UNSPECIFIED&lt;/code&gt;模式指定一个默认大小：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onMeasure&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;widthMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;heightMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;setMeasuredDimension&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;measureSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;widthMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="n"&gt;measureSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heightMeasureSpec&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;measureSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;measureSpec&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MeasureSpec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMode&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;measureSpec&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MeasureSpec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;measureSpec&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MeasureSpec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;EXACTLY&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//Default size&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;min&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;MeasureSpec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;measureSpec&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;至于更复杂的计算逻辑由于本人能力有限就不写demo了，如果以后实际中遇到需要的时候再作补充。&lt;/p&gt;</content><category term="Android"></category><category term="View"></category></entry><entry><title>Android PropertyAnimation 属性动画（一）初探</title><link href="/android-propertyanimation-shu-xing-dong-hua-yi-chu-tan.html" rel="alternate"></link><published>2017-03-10T14:14:45+08:00</published><updated>2017-03-10T14:14:45+08:00</updated><author><name>Di Wu</name></author><id>tag:None,2017-03-10:/android-propertyanimation-shu-xing-dong-hua-yi-chu-tan.html</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;相对于静态的页面，动画往往能更直观地表达所需的信息，在UI开发过程中起着相当大的作用。&lt;/p&gt;
&lt;p&gt;Android为我们提供了一系列实现动画效果的方法，&lt;code&gt;PropertyAnimaiton&lt;/code&gt;是最常见也是最实用的一种，如同它的名字一样，它的实现方式是通过改变对象的一系列属性值来改变对象的状态， 例如动态地改变绘制的位置就可以实现绘制物体的移动效果，动态地改变对象的显示状态可以实现闪烁效果。&lt;/p&gt;
&lt;h2&gt;Animator概览&lt;/h2&gt;
&lt;p&gt;Android提供的实现属性动画的工具是&lt;code&gt;android.animation.Animator&lt;/code&gt;这个类，它的使用需要配合&lt;code&gt;animation&lt;/code&gt;包下的其他工具类，这个类的功能是什么，我们要如何使用它来实现属性动画呢？&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;我们可以将&lt;code&gt;Animator&lt;/code&gt;理解为&lt;code&gt;Android&lt;/code&gt;为我们提供的一个按我们的需要在一定时间段内&lt;strong&gt;连续地&lt;/strong&gt;计算并返回值的工具，这个值可以是通用的整型、浮点型，也可以是我们自定义的类型。&lt;/p&gt;
&lt;p&gt;我们可以设置返回值的范围，并可以控制值变化的快慢，例如实现自由落体下落的物体时我们需要让高度值以一个越来越快的速度降低。&lt;/p&gt;
&lt;p&gt;这里的连续需要注意，实际上是不可能产生真正意义上的连续值的，但是如果&lt;strong&gt;在绘制过程中计算这个值的速度小于绘制一帧所需要的时间&lt;/strong&gt;，那么我们就可以在视觉上认为这个值是在连续改变的。这一点也是理解其作用的关键：我们很难去写出一个可以随时获取连续值的工具，而&lt;code&gt;Animator&lt;/code&gt;正是一个满足我们这个需求的一个通用工具。&lt;/p&gt;
&lt;p&gt;通过将&lt;code&gt;Animator&lt;/code&gt;与&lt;code&gt;View&lt;/code&gt;的绘制过程结合 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;相对于静态的页面，动画往往能更直观地表达所需的信息，在UI开发过程中起着相当大的作用。&lt;/p&gt;
&lt;p&gt;Android为我们提供了一系列实现动画效果的方法，&lt;code&gt;PropertyAnimaiton&lt;/code&gt;是最常见也是最实用的一种，如同它的名字一样，它的实现方式是通过改变对象的一系列属性值来改变对象的状态， 例如动态地改变绘制的位置就可以实现绘制物体的移动效果，动态地改变对象的显示状态可以实现闪烁效果。&lt;/p&gt;
&lt;h2&gt;Animator概览&lt;/h2&gt;
&lt;p&gt;Android提供的实现属性动画的工具是&lt;code&gt;android.animation.Animator&lt;/code&gt;这个类，它的使用需要配合&lt;code&gt;animation&lt;/code&gt;包下的其他工具类，这个类的功能是什么，我们要如何使用它来实现属性动画呢？&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;我们可以将&lt;code&gt;Animator&lt;/code&gt;理解为&lt;code&gt;Android&lt;/code&gt;为我们提供的一个按我们的需要在一定时间段内&lt;strong&gt;连续地&lt;/strong&gt;计算并返回值的工具，这个值可以是通用的整型、浮点型，也可以是我们自定义的类型。&lt;/p&gt;
&lt;p&gt;我们可以设置返回值的范围，并可以控制值变化的快慢，例如实现自由落体下落的物体时我们需要让高度值以一个越来越快的速度降低。&lt;/p&gt;
&lt;p&gt;这里的连续需要注意，实际上是不可能产生真正意义上的连续值的，但是如果&lt;strong&gt;在绘制过程中计算这个值的速度小于绘制一帧所需要的时间&lt;/strong&gt;，那么我们就可以在视觉上认为这个值是在连续改变的。这一点也是理解其作用的关键：我们很难去写出一个可以随时获取连续值的工具，而&lt;code&gt;Animator&lt;/code&gt;正是一个满足我们这个需求的一个通用工具。&lt;/p&gt;
&lt;p&gt;通过将&lt;code&gt;Animator&lt;/code&gt;与&lt;code&gt;View&lt;/code&gt;的绘制过程结合，就可以实现绝大多数的动画效果， 但是&lt;code&gt;Animator&lt;/code&gt;也不只局限在使用在绘制动画，只要是有相似需求的地方都可以使用它来实现， 同时由于属性动画只针对属性进行修改，与被修改对象之前几乎没有耦合，不需要对被修改对象作出改变，可以设置方式也多种多样，这些都是动画的另一种实现方法&lt;code&gt;ViewAnimator&lt;/code&gt;所无法做到的，所以我属性动画是现在实现动画效果的普遍做法。&lt;/p&gt;
&lt;h2&gt;使用Animator&lt;/h2&gt;
&lt;h3&gt;Animator子类&lt;/h3&gt;
&lt;p&gt;下面就来看看如何使用&lt;code&gt;Animator&lt;/code&gt;满足我们的需求。&lt;/p&gt;
&lt;p&gt;我们使用&lt;code&gt;Animator&lt;/code&gt;可以分为两个步骤，一是进行数值的计算，二是将计算出的数值设置到对应的对象上。而&lt;code&gt;Animator&lt;/code&gt;有着三个子类：&lt;code&gt;ValueAnimator&lt;/code&gt; &lt;code&gt;ObjectAnimator&lt;/code&gt; &lt;code&gt;AnimatorSet&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ValueAnimator&lt;/code&gt;实现了上述过程的第一个步骤：进行数值的计算。第二个步骤则需要我们重写它的回调在值发生改变时候手动地为对象更新属性值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ObjectAnimator&lt;/code&gt;则在其基础上进行了进一步的封装，加入了一些方法使得它可以绑定一个对象，在数值改变的同时对对象的属性进行更新。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AnimatorSet&lt;/code&gt;可以对&lt;code&gt;Animator&lt;/code&gt;进行组合，让它们之间进行联动，例如可以设置一个动画根据另一个动画的状态来决定是否开始、暂停或停止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，&lt;code&gt;ValueAnimator&lt;/code&gt;提供了一个&lt;code&gt;Animator&lt;/code&gt;最核心的内容，也是使用中最为灵活的一个。&lt;code&gt;ObjectAnimator&lt;/code&gt;由于绑定了相应的对象，在使用上会受一些限制。&lt;code&gt;AnimatorSet&lt;/code&gt;专用于需要组合动画的场景。&lt;/p&gt;
&lt;h3&gt;ValueAnimator&lt;/h3&gt;
&lt;p&gt;在这篇博客中，我们关注最为核心的&lt;code&gt;ValueAnimator&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;关键属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ValueAnimator&lt;/code&gt;对象内部维护了一系列属性来保存所需的各种信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Duration&lt;/code&gt;：动画的持续时间，通过&lt;code&gt;setDuration()&lt;/code&gt;方法设置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Repeat count and behavior&lt;/code&gt;：重复计数与重复模式，我们可以通过设置这两个属性来控制动画是否重复以及重复的次数，通过&lt;code&gt;setRepeatCount()&lt;/code&gt;与&lt;code&gt;setRepeatMode()&lt;/code&gt;方法设置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Frame refresh delay&lt;/code&gt;：帧刷新延迟，也就是计算两帧动画之间的间隔时间，但这个时间只是&lt;code&gt;Animator&lt;/code&gt;尽力去保持的值，具体的间隔时间会由于系统负载与性能的不同而不同，同时设置它的方法为一个静态方法：&lt;code&gt;ValueAnimator.setFrameDelay()&lt;/code&gt;，会被设置到所有的&lt;code&gt;Animator&lt;/code&gt;上，这是因为这些&lt;code&gt;Animator&lt;/code&gt;都在同一个时间循环中。这个属性也有可能会被忽略如果动画系统采用了内部的计时来源，例如&lt;code&gt;vsync&lt;/code&gt;来计算属性。同时这个方法需要在与&lt;code&gt;start()&lt;/code&gt;方法相同的进程中调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Time interpolation&lt;/code&gt;：时间插值器，是我们实现不同动画效果的关键，每一时刻所返回的数值由它决定，后文会详细讲&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;初始化与TypeEvaluator&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ValueAnimator&lt;/code&gt;对象的构造函数只由内部使用，获取&lt;code&gt;ValueAnimator&lt;/code&gt;对象的方法是调用它的工厂方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ValueAnimator.ofArgb()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ValueAnimator.ofInt()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ValueAnimator.ofFloat()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ValueAnimator.ofObject()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ValueAnimator.ofPropertyValuesHolder()&lt;/code&gt; //本篇未涉及，下一篇进行讲解&lt;/p&gt;
&lt;p&gt;前三个可以看作是&lt;code&gt;ValueAnimator&lt;/code&gt;为我们提供的初始化方式，它们的参数都是对应类型的长度可变参数:&lt;code&gt;(Type ...values)&lt;/code&gt;，我们需要提供一个以上的参数，&lt;code&gt;ValueAnimator&lt;/code&gt;最终提供的值会在这些值之前变动。&lt;/p&gt;
&lt;p&gt;一般情况下这里提供的&lt;code&gt;Argb&lt;/code&gt;（用于颜色值的变化）和整型、浮点值基本可以满足我们的需求，但是某些时候我们需要结果是我们自定义的一些对象，这个时候就需要用到&lt;code&gt;TypeEvaluator&amp;lt;&amp;gt;&lt;/code&gt;接口了，与这个接口对应的工厂方法是&lt;code&gt;ValueAnimator.ofObject()&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ValueAnimator&lt;/span&gt; &lt;span class="nf"&gt;ofObject&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TypeEvaluator&lt;/span&gt; &lt;span class="n"&gt;evaluator&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; 
                &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的可变参数类型变为了&lt;code&gt;Object&lt;/code&gt;，同时还需要我们提供一个&lt;code&gt;TypeEvaluator&amp;lt;&amp;gt;&lt;/code&gt;，用于“告诉”&lt;code&gt;Animator&lt;/code&gt;如何返回这个&lt;code&gt;Object&lt;/code&gt;值。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;TypeEvaluator&amp;lt;&amp;gt;&lt;/code&gt;接口并不复杂，只有一个方法需要我们重写：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="nf"&gt;evaluate&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;fraction&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; 
                &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;startValue&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; 
                &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;endValue&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;startValue&lt;/code&gt;与&lt;code&gt;endValue&lt;/code&gt;非常好理解，就是我们在获取&lt;code&gt;Animator&lt;/code&gt;时指定的值的起始值和结束值。类型与返回类型一致，当然都是我们自定义的类型。&lt;/p&gt;
&lt;p&gt;这里的&lt;code&gt;fraction&lt;/code&gt;就是决定我们最终返回值的关键参数。我们可以把这个&lt;code&gt;fraction&lt;/code&gt;理解为&lt;code&gt;animator&lt;/code&gt;提供给我们的最终的数值改变的比例，以小数表示，小于0表示低于&lt;code&gt;startValue&lt;/code&gt;，大于0表示超出&lt;code&gt;endValue&lt;/code&gt;，0-1之间表示在&lt;code&gt;startValue&lt;/code&gt;与&lt;code&gt;endValue&lt;/code&gt;之间。我们要做的就是把这个值转换为在起始和结果范围之间的合适的对象值。&lt;/p&gt;
&lt;p&gt;例如，对于基本的浮点类型，默认的&lt;code&gt;FloatEvaluator&lt;/code&gt;是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Float&lt;/span&gt; &lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;fraction&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;startValue&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;endValue&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;startFloat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;startValue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;floatValue&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;startFloat&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fraction&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;endValue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;floatValue&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;startFloat&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，就是相当于把&lt;code&gt;fraction&lt;/code&gt;所表示的比例“投射”到了我们所需要的数据对象上，这里是浮点类型。如果使用我们的自定义类型，我们必须为自己的类型定义这样的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这里要求我们必须将&lt;code&gt;fraction&lt;/code&gt;&lt;strong&gt;线性&lt;/strong&gt;地反应到对应的类型上，因为&lt;code&gt;fraction&lt;/code&gt;反映的是最终的动画进度，我们必须如实地按照这个进度改变我们的属性，所以需要将result = x0 + t * (x1 - x0)`这样的形式反映到我们自己的对象上。&lt;/p&gt;
&lt;p&gt;自定义了&lt;code&gt;TypeEvaluator&lt;/code&gt;以后就可以作为参数使用在上面的&lt;code&gt;obObject()&lt;/code&gt;工厂方法中了。&lt;/p&gt;
&lt;h4&gt;插补细分器(&lt;code&gt;Interpolators&lt;/code&gt;)&lt;/h4&gt;
&lt;p&gt;下面介绍使用&lt;code&gt;ValueAnimator&lt;/code&gt;控制值变化过程中最为重要的一个概念：插补细分器(&lt;code&gt;Interpolators&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;它实际上是一个关于时间的函数， 根据时刻的不同来返回不同的值，进而来控制最后的输出的值。那么它是如何表示的呢？&lt;/p&gt;
&lt;p&gt;系统为我们提供了一系列预置的&lt;code&gt;Interpolators&lt;/code&gt;，以较常用的&lt;code&gt;LinearInterpolater&lt;/code&gt;为例，顾名思义，它是一个线性的插补细分器，意味着输入与输出呈线性关系：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="nf"&gt;getInterpolation&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输入输出的关键函数就是这个&lt;code&gt;getInterpolation()&lt;/code&gt;了，可以看到，参数与返回值都是&lt;code&gt;float&lt;/code&gt;类型，&lt;code&gt;input&lt;/code&gt;的值在0-1之间，结合前面，我们可以很容易理解，这个&lt;code&gt;input&lt;/code&gt;就是一个以0-1之间的小数表示的过去的时间值，例如整个动画是1000ms，当&lt;code&gt;input&lt;/code&gt;为0.25的时候意味着现在的时间过去了250ms。&lt;/p&gt;
&lt;p&gt;而返回值就是经过我们的转换，表示出的动画应该进行的时间的比例，这里由于是线性的，所以可以直接返回&lt;code&gt;input&lt;/code&gt;，这个值最后会到哪里呢？自然就是给我们前面介绍的&lt;code&gt;TypeEvaluator&lt;/code&gt;。下面一段源码展示了这个过程：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mInterpolator&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;fraction&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mInterpolator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInterpolation&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fraction&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;mEvaluator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;evaluate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fraction&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mFirstKeyframe&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getValue&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt;
        &lt;span class="n"&gt;mLastKeyframe&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getValue&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;作为&lt;code&gt;getInterpolation()&lt;/code&gt;参数的&lt;code&gt;fraction&lt;/code&gt;代表着过去的时间比例，这里调用我们设置的&lt;code&gt;Interpolator&lt;/code&gt;来更新这个&lt;code&gt;fraction&lt;/code&gt;，现在这个&lt;code&gt;fraction&lt;/code&gt;表示的就是动画已经进行的比例，下一步就要根据它来获取对应的对象值（调用了我们之间谈到过的&lt;code&gt;evaluate()&lt;/code&gt;方法，这里的&lt;code&gt;KeyFrame&lt;/code&gt;的概念会在之后的博客讲到），后面的两个参数就是传递给&lt;code&gt;evaluate&lt;/code&gt;的起始与结束范围。&lt;/p&gt;
&lt;p&gt;最终，我们就获得了一个按照我们设定的&lt;code&gt;Interpolator&lt;/code&gt;返回的动画属性值。&lt;/p&gt;
&lt;p&gt;如果想要实现加速效果呢？Android同样为我们提供了现成的&lt;code&gt;AccelerateInterpolator&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="nf"&gt;getInterpolation&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mFactor&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;pow&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mDoubleFactor&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样很简洁，这里用到了&lt;code&gt;mFactor&lt;/code&gt;与&lt;code&gt;mDoubleFactor&lt;/code&gt;分别表示我们在构造函数里面设置的指数值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;AccelerateInterpolator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;factor&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;mFactor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;factor&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;mDoubleFactor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;mFactor&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们设置的为1，会返回&lt;code&gt;input&lt;/code&gt;的平方，其他值则会返回&lt;code&gt;input&lt;/code&gt;的&lt;code&gt;mDoubleFactor&lt;/code&gt;次方，使得动画属性可以以不同的函数曲线形式变化。&lt;/p&gt;
&lt;p&gt;如果我们要实现自己的&lt;code&gt;Interpolator&lt;/code&gt;呢？只需要实现&lt;code&gt;TimeInterpolator&lt;/code&gt;接口，这个接口只需要我们实现一个&lt;code&gt;getInterpolation&lt;/code&gt;方法。我们可以根据&lt;code&gt;input&lt;/code&gt;值返回不同的值来返回不同的值表示动画的进度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;返回值的范围不一定要在0-1之间，小于0或大小1的值可以表示超出预设范围的目标值。&lt;/p&gt;
&lt;p&gt;这篇博客到此结束，在下一篇博客中将会以一个绘制自由落体的弹跳小球的示例来演示如何使用&lt;code&gt;Animator&lt;/code&gt;与介绍它的回调函数。&lt;/p&gt;</content><category term="Android"></category><category term="UI"></category><category term="Animation"></category></entry><entry><title>汇编语言综合研究</title><link href="/hui-bian-yu-yan-zong-he-yan-jiu.html" rel="alternate"></link><published>2017-03-10T10:35:37+08:00</published><updated>2017-03-10T10:35:37+08:00</updated><author><name>Zhihao Chen</name></author><id>tag:None,2017-03-10:/hui-bian-yu-yan-zong-he-yan-jiu.html</id><summary type="html">&lt;h2&gt;研究试验1 搭建一个精简的C语言开发环境&lt;/h2&gt;
&lt;p&gt;TC进行连接需要如下的文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C0S.OBJ&lt;/li&gt;
&lt;li&gt;CS.LIB&lt;/li&gt;
&lt;li&gt;EMU.LIB&lt;/li&gt;
&lt;li&gt;GRAPHICS.LIB&lt;/li&gt;
&lt;li&gt;MATHS.LIB&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;研究试验2 使用寄存器&lt;/h2&gt;
&lt;ol&gt;
&lt;li _="%" endcodeblock&gt;编一个程序ur1.c
    {% codeblock lang:c %}
    main ()
    {
        _AX = 1;
        _BX = 1;
        _CX = 2;
        _AX = _BX + _CX;
        _AH = _BL + _CL;
        _AL = _BH + _CH;
    }&lt;/li&gt;
&lt;li&gt;用Debug加载ur1.exe，用u命令查看ur1.exe编译后的机器码和汇编代码。
    思考：main函数的代码在什么段中？用Debug怎样找到ur1.exe中main函数的代码？
    回答：main函数的代码在CS段中，需要知道main函数的偏移地址才能找到main函数的代码。&lt;/li&gt;
&lt;li&gt;用下面的方法打印出ur1.exe被加载运行时，main函数在代码段中的偏移地址 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h2&gt;研究试验1 搭建一个精简的C语言开发环境&lt;/h2&gt;
&lt;p&gt;TC进行连接需要如下的文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C0S.OBJ&lt;/li&gt;
&lt;li&gt;CS.LIB&lt;/li&gt;
&lt;li&gt;EMU.LIB&lt;/li&gt;
&lt;li&gt;GRAPHICS.LIB&lt;/li&gt;
&lt;li&gt;MATHS.LIB&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;研究试验2 使用寄存器&lt;/h2&gt;
&lt;ol&gt;
&lt;li _="%" endcodeblock&gt;编一个程序ur1.c
    {% codeblock lang:c %}
    main ()
    {
        _AX = 1;
        _BX = 1;
        _CX = 2;
        _AX = _BX + _CX;
        _AH = _BL + _CL;
        _AL = _BH + _CH;
    }&lt;/li&gt;
&lt;li&gt;用Debug加载ur1.exe，用u命令查看ur1.exe编译后的机器码和汇编代码。
    思考：main函数的代码在什么段中？用Debug怎样找到ur1.exe中main函数的代码？
    回答：main函数的代码在CS段中，需要知道main函数的偏移地址才能找到main函数的代码。&lt;/li&gt;
&lt;li&gt;用下面的方法打印出ur1.exe被加载运行时，main函数在代码段中的偏移地址。
    {% codeblock lang:c %}
    main ()
    {
        printf("%x\n", main);
    }
    {% endcodeblock %}
    思考：为什么这个程序能够打印出main函数在代码段中的偏移地址？
    回答：由学过的知识可知，C语言中用指针表示地址，这里的printf打印了main函数的入口地址，也即main函数在代码段中的偏移地址。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用Debug加载ur1.exe，根据上面打印出的main函数的偏移地址，用u命令察看main函数的汇编代码。仔细找到ur1.c中每条C语句对应的汇编代码。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;地址&lt;/th&gt;
&lt;th align="center"&gt;汇编语句&lt;/th&gt;
&lt;th align="center"&gt;C语句&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:01FA&lt;/td&gt;
&lt;td align="center"&gt;PUSH BP&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:01FB&lt;/td&gt;
&lt;td align="center"&gt;MOV BP,SP&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:01FD&lt;/td&gt;
&lt;td align="center"&gt;MOV AX,0001&lt;/td&gt;
&lt;td align="center"&gt;_AX = 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0200&lt;/td&gt;
&lt;td align="center"&gt;MOV BX,0001&lt;/td&gt;
&lt;td align="center"&gt;_BX = 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0203&lt;/td&gt;
&lt;td align="center"&gt;MOV CX,0002&lt;/td&gt;
&lt;td align="center"&gt;_CX = 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0206&lt;/td&gt;
&lt;td align="center"&gt;MOV AX,BX&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0208&lt;/td&gt;
&lt;td align="center"&gt;ADD AX,CX&lt;/td&gt;
&lt;td align="center"&gt;_AX = _BX + _CX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:020A&lt;/td&gt;
&lt;td align="center"&gt;MOV AH,BL&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:020C&lt;/td&gt;
&lt;td align="center"&gt;ADD AH,CL&lt;/td&gt;
&lt;td align="center"&gt;_AH = _BL + _CL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:020E&lt;/td&gt;
&lt;td align="center"&gt;MOV AL,BH&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0210&lt;/td&gt;
&lt;td align="center"&gt;ADD AL,CH&lt;/td&gt;
&lt;td align="center"&gt;_AL = _BH + _CH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0212&lt;/td&gt;
&lt;td align="center"&gt;POP BP&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0213&lt;/td&gt;
&lt;td align="center"&gt;RET&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注意：在这里，对于main函数汇编代码开始处的“push bp mov bp,sp”和结尾处的“pop bp”，这里只了解到：这是C编译器安排的为函数中可能使用到bp寄存器而设置的，就可以了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过main函数后面有ret指令，我们可以设想：C语言将函数实现为汇编语言中的子程序。研究下面程序的汇编代码，验证我们的设想。
    {% codeblock lang:c %}
    void f(void);&lt;/p&gt;
&lt;p&gt;main()
{
    _AX = 1; _BX = 1; _CX = 2;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;f();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void f(void)
{
    _AX = _BX + _CX;
}
{% endcodeblock %}
编译、连接后用Debug查看汇编代码如下：
{% codeblock lang:x86asm %}
PUSH BP
MOV BP,SP
MOV AX,0001
MOV BX,0001
MOV CX,0002
CALL 020B
POP BP
RET
PUSH BP
MOV BP,SP
MOV AX,BX
ADD AX,CX
POP BP
RET
{% endcodeblock %}
设想正确&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;研究试验3 使用内存空间&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编一个程序um1.c：
    {% codeblock lang:c %}
    main()
    {
        &lt;em&gt;(char &lt;/em&gt;)0x2000='a';
        &lt;em&gt;(int &lt;/em&gt;)0x2000=0xf;
        &lt;em&gt;(char far &lt;/em&gt;)0x20001000='a';&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;_AX=0x2000;
*(char *)_AX=&amp;#39;b&amp;#39;;

_BX=0x1000;
*(char *)(_BX+_BX)=&amp;#39;a&amp;#39;;
*(char far *)(0x20001000+_BX)=*(char *)_AX;
&lt;/pre&gt;&lt;/div&gt;


&lt;p _="%" endcodeblock&gt;}&lt;/p&gt;
&lt;p&gt;把um1.c保存在C:\MINIC下，编译，连接生成um1.exe。然后用Debug加载um1.exe，对main函数的汇编代码进行分析，找到每条C语句对应的汇编代码；对main函数进行单步跟踪，察看相关内存单元的内容。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;地址&lt;/th&gt;
&lt;th align="center"&gt;汇编语句&lt;/th&gt;
&lt;th align="center"&gt;C语句&lt;/th&gt;
&lt;th align="center"&gt;相关内存单元&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:01FA&lt;/td&gt;
&lt;td align="center"&gt;PUSH BP&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:01FB&lt;/td&gt;
&lt;td align="center"&gt;MOV BP,SP&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:01FD&lt;/td&gt;
&lt;td align="center"&gt;MOV BYTE PTR [2000],61&lt;/td&gt;
&lt;td align="center"&gt;*(char *)0x2000='a'&lt;/td&gt;
&lt;td align="center"&gt;07C4:2000 -&amp;gt; 61&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0202&lt;/td&gt;
&lt;td align="center"&gt;MOV WORD PTR [2000],000F&lt;/td&gt;
&lt;td align="center"&gt;*(int *)0x2000=0xf&lt;/td&gt;
&lt;td align="center"&gt;07C4:2000-07C4:2001 -&amp;gt; 0F 00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0208&lt;/td&gt;
&lt;td align="center"&gt;MOV BX,2000&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:020B&lt;/td&gt;
&lt;td align="center"&gt;MOV ES,BX&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:020D&lt;/td&gt;
&lt;td align="center"&gt;MOV BX,1000&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0210&lt;/td&gt;
&lt;td align="center"&gt;ES:&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0211&lt;/td&gt;
&lt;td align="center"&gt;MOV BYTE PTR [BX],61&lt;/td&gt;
&lt;td align="center"&gt;*(char far *)0x20001000='a'&lt;/td&gt;
&lt;td align="center"&gt;2000:1000 -&amp;gt; 61&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0214&lt;/td&gt;
&lt;td align="center"&gt;MOV AX,2000&lt;/td&gt;
&lt;td align="center"&gt;_AX=0x2000&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0217&lt;/td&gt;
&lt;td align="center"&gt;MOV BX,AX&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0219&lt;/td&gt;
&lt;td align="center"&gt;MOV BYTE PTR [BX],62&lt;/td&gt;
&lt;td align="center"&gt;*(char *)_AX='b'&lt;/td&gt;
&lt;td align="center"&gt;07C4:2000 -&amp;gt; 62&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:021C&lt;/td&gt;
&lt;td align="center"&gt;MOV BX,1000&lt;/td&gt;
&lt;td align="center"&gt;_BX=0x1000&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:021F&lt;/td&gt;
&lt;td align="center"&gt;ADD BX,BX&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0221&lt;/td&gt;
&lt;td align="center"&gt;MOV BYTE PTR [BX],61&lt;/td&gt;
&lt;td align="center"&gt;*(char *)(_BX + _BX)='a'&lt;/td&gt;
&lt;td align="center"&gt;07C4:2000 -&amp;gt; 61&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0224&lt;/td&gt;
&lt;td align="center"&gt;MOV BX,AX&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0226&lt;/td&gt;
&lt;td align="center"&gt;MOV AL,[BX]&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0228&lt;/td&gt;
&lt;td align="center"&gt;XOR CX,CX&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:022A&lt;/td&gt;
&lt;td align="center"&gt;ADD BX,1000&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:022E&lt;/td&gt;
&lt;td align="center"&gt;ADC CX,2000&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0232&lt;/td&gt;
&lt;td align="center"&gt;MOV ES,CX&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0234&lt;/td&gt;
&lt;td align="center"&gt;ES:&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0235&lt;/td&gt;
&lt;td align="center"&gt;MOV [BX],AL&lt;/td&gt;
&lt;td align="center"&gt;*(char far *)(0x20001000+_BX)=*(char *)_AX&lt;/td&gt;
&lt;td align="center"&gt;2000:3000 -&amp;gt; 61&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0237&lt;/td&gt;
&lt;td align="center"&gt;POP BP&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;076A:0238&lt;/td&gt;
&lt;td align="center"&gt;RET&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;td align="center"&gt;----&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;编一个程序，用一条C语句实现在屏幕的中间显示一个绿色的字符"a"。
    {% codeblock lang:c %}
    main()
    {
        &lt;em&gt;(int far &lt;/em&gt;)0xb80007d0=0x261
    }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析下面程序中所有函数的汇编代码，思考相关的问题。
    {% codeblock lang:c %}
    int a1, a2, a3;
    void f(void);
    main()
    {
        int b1, b2, b3;
        a1 = 0xa1; a2 = 0xa2; a3 = 0xa3;
        b1 = 0xb1; b2 = 0xb2; b3 = 0xb3;
    }
    void f(void)
    {
        int c1, c2, c3;
        a1 = 0x0fa1; a2 = 0x0fa2; a3 = 0x0fa3;
        c1 = 0xc1; c2 = 0xc2; c3 = 0xc3;
    }
    {% endcodeblock %}
    问题：C语言将全局变量存放在哪里？将局部变量存放在哪里？每个函数开头的“push bp mov bp,sp”有何含义？
    程序中main函数的汇编代码如下：
    {% codeblock lang:x86asm %}
    PUSH BP
    MOV BP, SP
    SUB SP, 6
    MOV WORD PTR [01A6], 00A1
    MOV WORD PTR [01A8], 00A2
    MOV WORD PTR [01AA], 00A3
    MOV WORD PTR [BP-6], 00B1
    MOV WORD PTR [BP-4], 00B2
    MOV WORD PTR [BP-2], 00B3
    MOV SP, BP
    POP BP
    RET
    {% endcodeblock %}
    程序中f函数的汇编代码如下：
    {% codeblock lang:x86asm %}
    PUSH BP
    MOV BP, SP
    SUB SP, 6
    MOV WORD PTR [01A6], 0FA1
    MOV WORD PTR [01A8], 0FA2
    MOV WORD PTR [01AA], 0FA3
    MOV WORD PTR [BP-6], 00C1
    MOV WORD PTR [BP-4], 00C2
    MOV WORD PTR [BP-2], 00C3
    MOV SP, BP
    POP BP
    RET
    {% endcodeblock %}
    答案：
    C语言将全局变量存放在内存中，将局部变量存放在栈中，每个函数开头的push bp以及mov bp,sp是为了保护与还原现场。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析下面程序的汇编代码，思考相关的问题。
    {% codeblock lang:c %}
    int f(void);&lt;/p&gt;
&lt;p&gt;int a,b,ab;&lt;/p&gt;
&lt;p&gt;main()
{
    int c;
    c = f();
}
int f(void)
{
    ab=a+b;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;return ab;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}
{% endcodeblock %}
问题：C语言将函数的返回值存放在哪里？
程序中main函数的汇编代码如下：
{% codeblock lang:x86asm %}
PUSH BP
MOV BP, SP
SUB SP, 2
CALL 020A
MOV [BP-2], AX
MOV SP, BP
POP BP
RET
{% endcodeblock %}
程序中f函数的汇编代码如下：
{% codeblock lang:x86asm %}
PUSH BP
MOV BP, SP
MOV AX, [01A6]
ADD AX, [01A8]
MOV [01AA], AX
MOV AX, [01AA]
JMP 021C
POP BP
RET
{% endcodeblock %}
答案：
在该情况下，C语言将返回值存放在通用寄存器AX中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面的程序向安全的内存空间写入从“a”到“h”8个字符，理解程序的含义，深入理解相关的知识。（注意：请自己学习、研究malloc函数的用法）
    {% codeblock lang:c %}
    #define Buffer ((char &lt;em&gt;) * (int far &lt;/em&gt;)0x02000000)&lt;/p&gt;
&lt;p&gt;main()
{
    Buffer = (char *)malloc(20);&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Buffer[10] = 0;

while(Buffer[10]!=8)
{
    Buffer[Buffer[10]]=&amp;#39;a&amp;#39;+Buffer[10];
    Buffer[10]++;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}
{% endcodeblock %}
理解：
程序通过malloc分配大小为20字节的空间给并将其地址存入Buffer所指向的空间即0200:0000中。随后，通过一个while循环将这20个字节的空间的0-7个字节分别赋予对应的字符，并且用第10个字节计数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;研究试验4 不用main函数编程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;把程序F.C保存在C:\MINIC下，对其进行编译，连接，思考相关的问题。
    问题：
    ①编译和连接哪个环节会出问题？
    ②显示出的错误信息是什么？
    ③这个错误信息可能和哪个文件有关？
    答案：
    ①连接环节出现了错误
    ②在C0S模块中未定义的标号_main
    ③和C0S.OBJ这个文件有关&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用学习汇编语言时使用的LINK.EXE对TC.EXE生成的F.OBJ文件进行连接，生成F.EXE。用DEBUG加载F.EXE，察看整个程序的汇编代码。思考相关的问题。
    问题：
    ①F.EXE的程序代码总共有多少字节？
    ②F.EXE的程序能正确返回吗？
    ③F函数的偏移地址是多少？
    答案：
    ①F.EXE的程序代码总共有1DH个字节
    ②F.EXE的程序不能正确的返回
    ③F函数的偏移地址为0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写一个程序M.C。
    {% codeblock lang:c %}
    main ()
    {
        &lt;em&gt;(char far &lt;/em&gt;)(0xb8000000+160&lt;em&gt;10+80)='a';
        &lt;/em&gt;(char far &lt;em&gt;)(0xb8000000+160&lt;/em&gt;10+81)=2;
    }
    {% endcodeblock %}
    用TC.EXE对M.C进行编译，连接，生成M.EXE，用Debug察看M.EXE整个程序的汇编代码。思考相关的问题。
    问题：
    ①M.EXE的程序代码总共有多少字节？
    ②M.EXE的程序能正确返回吗？
    ③M.EXE程序中的main函数和F.EXE中的f函数的汇编代码有何不同？
    答案：
    ①M.EXE的程序代码总共有5F5H个字节
    ②M.EXE的程序能正确返回
    ③M.EXE程序中的main函数和F.EXE中的f函数的汇编代码没有不同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用Debug对m.exe进行跟踪：
    ①找到对main函数进行调用的指令的地址
    ②找到整个程序返回的指令
    注意：使用g命令和p命令。
    答案：
    ①对main函数进行调用的指令的地址为076A:011A CALL 01FA
    ②整个程序返回的指令为076A:0156 INT 21&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;思考如下几个问题：
    ①对main函数调用的指令和程序返回的指令是哪里来的？
    ②没有main函数时，出现的错误信息里有和“C0S”相关的信息；而前面在搭建开发环境时，没有C0S.OBJ文件TC.EXE就无法对程序进行连接。是不是TC.EXE把C0S.OBJ和用户程序的.OBJ一起进行连接生成.EXE文件？
    ③对用户程序的main函数进行调用的指令和程序返回的指令是否就来自C0S.OBJ文件？
    ④我们如何看到C0S.OBJ文件中的程序代码呢？
    ⑤C0S.OBJ文件里有我们设想的代码吗？
    回答：
    ①对main函数调用的指令和程序返回的指令是来自于其他的文件而非编译后的文件。
    ②是的
    ③是的
    ④用LINK.EXE对其进行连接即可
    ⑤有&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用LINK.EXE对C:\MINIC目录下的C0S.OBJ进行连接，生成C0S.EXE。
    用Debug分别察看C0S.EXE和M.EXE的汇编代码。注意：从头开始察看，两个文件中的程序代码有和相同之处？
    两个程序的代码基本相同，且都是在011A调用了CALL指令，在0156调用了INT 21中断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用Debug找到M.EXE中调用main函数的CALL指令的偏移地址，从这个偏移地址开始向后察看10条指令；然后用Debug加载C0S.EXE，从相同的偏移地址开始向后察看10条指令，对两处的指令进行对比。
    M.EXE和C0S.EXE在偏移地址011A之后的10条指令除了跳转指令的跳转地址有所不同外几乎完全相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面，我们用汇编语言编一个程序C0S.ASM，然后把它编译为C0S.OBJ，替代C:\MINIC目录下的C0S.OBJ。
    程序C0S.ASM：
    {% codeblock lang:x86asm %}
    assume cs:code
    data segment
        db 128 dup (0)
    data ends&lt;/p&gt;
&lt;p&gt;code segment
start:  mov ax, data
        mov ds, ax
        mov ss, ax
        mov sp, 108&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    call s

    mov ax, 4c00h
    int 21h
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;s:      &lt;/p&gt;
&lt;p&gt;code ends&lt;/p&gt;
&lt;p _="%" endcodeblock&gt;end start&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p _="%" endcodeblock&gt;在C:\MINIC目录下，用TC.EXE将F.C重新进行编译，连接，生成F.EXE。这次能通过连接吗？F.EXE可以正确运行吗？用Debug察看F.EXE的汇编代码。
    能通过连接，可以正确运行，汇编代码如下：
    {% codeblock lang:x86asm %}
    MOV AX,076A
    MOV DS,AX
    MOV SS,AX
    MOV SP,0080
    CALL 0012
    MOV AX,4C00
    INT 21
    MOV BP,SP
    MOV BX,B800
    MOV ES,BX
    MOV BX,0690
    ES:
    MOV BYTE PTR [BX],61
    MOV BX,B800
    MOV ES,BX
    MOV BX,0691
    ES:
    MOV BYTE PTR [BX],02
    POP BP
    RET
    ...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在新的C0S.OBJ的基础上，写一个新的F.C，向安全的内存空间写入从“a”到“h”的8个字符，分析、理解F.C。
    程序F.C：
    {% codeblock lang:c %}
    #define Buffer ((char &lt;em&gt;) * (int far &lt;/em&gt;)0x02000000)&lt;/p&gt;
&lt;p&gt;f()
{
    Buffer = 0;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Buffer[10] = 0;

while(Buffer[10]!=8)
{
    Buffer[Buffer[10]]=&amp;#39;a&amp;#39;+Buffer[10];
    Buffer[10]++;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p _="%" endcodeblock&gt;}
{% endcodeblock %}
汇编代码如下：
{% codeblock lang:x86asm %}
MOV AX,076A
MOV DS,AX
MOV SS,AX
MOV SP,0080
CALL 0012 ;调用f函数
INT 21
PUSH BP ;0012
MOV BP,SP
MOV BX,0200
MOV ES,BX
XOR BX,BX
ES:
MOV WORD PTR [BX],0000 ;设置Buffer=0，即将0200:0000处的内存单元改为0
MOV BX,0200
MOV ES,BX
XOR BX,BX
ES:
MOV BX,[BX] ;将Buffer解引用，即将0200:0000处的内存字单元存入BX中
MOV BYTE PTR [BX+0A],00 ;设置Buffer[10]=0 即将DS:000A处的内存单元改为0
JMP 006D ;while 循环条件判断
MOV BX,0200 ;0031
MOV ES,BX
XOR BX,BX
ES:
MOV BX,[BX] ;将Buffer解引用，即将0200:0000处的内存字单元存入BX中
MOV AL,[BX+0A] ;AL等于Buffer[10]，即将DS:000A内存字节单元的内容存入AL中
ADD AL,61 ;为AL加上'a'
MOV BX,0200
MOV ES,BX
XOR BX,BX
ES:
MOV BX,[BX] ;将Buffer解引用，即将0200:0000处的内存字单元存入BX中
PUSH AX
PUSH BX
MOV BX,0200
MOV ES,BX
XOR BX,BX
ES:
MOV BX,[BX] ;将Buffer解引用，即将0200:0000处的内存字单元存入BX中
MOV AL,[BX+0A] ;将Buffer[10]的值传入AL，即将DS:000A处的内存字节单元存入AL中
CBW ;将AL扩展至16位
POP BX ;取回BX
ADD BX,AX ;BX现在值为Buffer[10]
POP AX ;取回AX
MOV [BX],AL ;将所要设置的数值'a'+Buffer[10]存入Buffer[Buffer[10]]中
MOV BX,0200
MOV ES,BX
XOR BX,BX
ES:
MOV BX,[BX] ;将Buffer解引用，即将0200:0000处的内存字单元存入BX中
INC BYTE PTR [BX+0A] ;将Buffer[10]自增
MOV BX,0200 ;006D
MOV ES,BX
XOR BX,BX
ES:
MOV BX,[BX]
CMP BYTE PTR [BX+0A],08 ;判断Buffer[10]是否等于8
JNZ 0031 ;不等于则继续
POP BP ;等于则返回
RET&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;研究试验5 函数如何接受不定数量的参数&lt;/h2&gt;
&lt;p&gt;用C:\MINIC下的TC.EXE完成下面的试验。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;写一个程序A.C：
    {% codeblock lang:c %}
    void showchar(char a, int b);&lt;/p&gt;
&lt;p&gt;main()
{
    showchar('a', 2);
}&lt;/p&gt;
&lt;p&gt;void showchar(char a, int b)
{
    &lt;em&gt;(char far &lt;/em&gt;)(0xb8000000+160*10+80)=a;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*(char far *)(0xb8000000+160*10+81)=b;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}
{% endcodeblock %}
用TC.EXE对A.C进行编译，连接，生成A.EXE。用Debug加载A.EXE，对函数的汇编代码进行分析。解答这两个问题：main函数是如何给showchar传递参数的？showchar是如何接受参数的？
main函数的汇编代码如下：
{% codeblock lang:x86asm %}
PUSH BP
MOV BP,SP
MOV AX,0002
PUSH AX
MOV AL,61
PUSH AX
CALL 020B ;调用showchar函数
POP CX
POP CX
POP BP
RET
{% endcodeblock %}
showchar函数的汇编代码如下：
{% codeblock lang:x86asm %}
PUSH BP
MOV BP,SP
MOV AL,[BP+4]
MOV BX,B800
MOV ES,BX
MOV BX,0690
ES:
MOV [BX],AL ;f函数的第1条语句
MOV AL,[BP+6]
MOV BX,B800
MOV ES,BX
MOV BX,0691
ES:
MOV [BX],AL ;f函数的第2条语句
POP BP
RET
{% endcodeblock %}
答案：
main函数通过将对应的参数压栈来给showchar传递参数，并且在函数返回后通过POP操作将参数退栈。
showchar通过SS:BP以及寻址在栈中取得对应的参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写一个程序B.C：
    {% codeblock lang:c %}
    void showchar(int,int,...);&lt;/p&gt;
&lt;p&gt;main()
{
    showchar(8,2,'a','b','c','d','e','f','g','f');
}&lt;/p&gt;
&lt;p&gt;void showchar(int n,int color,...)
{
    int a;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for(a=0;a!=n;a++)
{
    *(char far *)(0xb8000000+160*10+80+a+a)=*(int *)(_BP+8+a+a);//加8是因～为call的时候将CS、IP压栈

    *(char far *)(0xb8000000+160*10+81+a+a)=color;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}
{% endcodeblock %}
分析程序B.C，深入理解相关的知识。
思考：showchar函数是如何知道要显示多少个字符的？printf函数是如何知道有多少个参数的？
待显示字符的个数为showchar函数的第一个参数，showchar函数以此得知要显示的字符的个数。
通过对printf的一个参数所指向的字符串的分析，printf函数以此得知参数的个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现一个简单的printf函数，只需支持“%c %d”即可。
    {% codeblock lang:c %}
    void myprintf(char *, ...);&lt;/p&gt;
&lt;p&gt;main()
{
    myprintf("%d %c abc %%\n", -12345, 48);
}&lt;/p&gt;
&lt;p _="%" endcodeblock&gt;void myprintf(char * str, ...)
{
    int count = 0;
    int position = 0;
    while (&lt;em&gt;str != 0)
    {
        if (&lt;/em&gt;str == 37)
        {
            str++;
            if (&lt;em&gt;str == 68 || &lt;/em&gt;str == 100)
            {
                int index;
                char flag = 0;
                int length = 0;
                int num = &lt;em&gt;(int &lt;/em&gt;)(_BP + 6 + count);
                if (num &amp;lt; 0) {
                    flag = 1;
                    num &lt;em&gt;= -1;
                }
                while (num != 0)
                {
                    num = num / 10;
                    length++;
                }
                num = &lt;/em&gt;(int &lt;em&gt;)(_BP + 6 + count);
                if (flag == 1) num &lt;/em&gt;= -1;
                position += length + flag - 1;
                for (index = 0 ; index &amp;lt; length; ++index)
                {
                    &lt;em&gt;(char far &lt;/em&gt;)(0xb8000000 + 1600 + position * 2) = num % 10 + 48;
                    num = num / 10;
                    position--;
                }
                if (flag == 1)
                {
                    &lt;em&gt;(char far &lt;/em&gt;)(0xb8000000 + 1600 + position * 2) = '-';
                    position--;
                }
                position += length + flag + 1;
                count += 2;
                str++;
            }
            else if (&lt;em&gt;str == 67 || &lt;/em&gt;str == 99)
            {
                &lt;em&gt;(char far &lt;/em&gt;)(0xb8000000 + 1600 + position * 2) = &lt;em&gt;(char &lt;/em&gt;)(_BP + 6 + count);
                count++;
                position++;
                str++;
            }
            else
            {
                &lt;em&gt;(char far &lt;/em&gt;)(0xb8000000 + 1600 + position * 2) = '%';
                position++;
            }
        }
        else
        {
            &lt;em&gt;(char far &lt;/em&gt;)(0xb8000000 + 1600 + position * 2) = *str;
            position++;
            str++;
        }
    }
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="汇编"></category><category term="实验"></category></entry><entry><title>Android View绘制生命周期总览</title><link href="/android-viewhui-zhi-sheng-ming-zhou-qi-zong-lan.html" rel="alternate"></link><published>2017-03-09T17:22:41+08:00</published><updated>2017-03-09T17:22:41+08:00</updated><author><name>Di Wu</name></author><id>tag:None,2017-03-09:/android-viewhui-zhi-sheng-ming-zhou-qi-zong-lan.html</id><summary type="html">&lt;p&gt;为了直观表示整个过程，我制作了一张流程图。注意以下只是整个生命周期中比较常用的方法，并不代表所有的过程。&lt;/p&gt;
&lt;p&gt;&lt;img alt="viewLifeCircle" src="/images/viewLifeCircle.png"&gt;&lt;/p&gt;
&lt;p&gt;当一个&lt;code&gt;Activity&lt;/code&gt;收到焦点即将要处于激活状态时，将会被要求绘制它的布局，绘制布局之前的过程在这里不涉及，我们从绘制&lt;code&gt;View&lt;/code&gt;开始分析。&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;Activity&lt;/code&gt;被要求提供一个&lt;code&gt;ViewGroup&lt;/code&gt;作为View树的根，也就是我们熟悉的&lt;code&gt;setContentView&lt;/code&gt;方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setContentView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nd"&gt;@LayoutRes&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;layoutResID&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;getDelegate&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;setContentView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;layoutResID&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setContentView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;getDelegate&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;setContentView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setContentView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ViewGroup&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;LayoutParams&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;getDelegate&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;setContentView …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;为了直观表示整个过程，我制作了一张流程图。注意以下只是整个生命周期中比较常用的方法，并不代表所有的过程。&lt;/p&gt;
&lt;p&gt;&lt;img alt="viewLifeCircle" src="/images/viewLifeCircle.png"&gt;&lt;/p&gt;
&lt;p&gt;当一个&lt;code&gt;Activity&lt;/code&gt;收到焦点即将要处于激活状态时，将会被要求绘制它的布局，绘制布局之前的过程在这里不涉及，我们从绘制&lt;code&gt;View&lt;/code&gt;开始分析。&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;Activity&lt;/code&gt;被要求提供一个&lt;code&gt;ViewGroup&lt;/code&gt;作为View树的根，也就是我们熟悉的&lt;code&gt;setContentView&lt;/code&gt;方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setContentView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nd"&gt;@LayoutRes&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;layoutResID&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;getDelegate&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;setContentView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;layoutResID&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setContentView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;getDelegate&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;setContentView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setContentView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ViewGroup&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;LayoutParams&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;getDelegate&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;setContentView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到&lt;code&gt;setContentView&lt;/code&gt;拥有三种形式，可以直接传入&lt;code&gt;View&lt;/code&gt;、传入一个&lt;code&gt;layout&lt;/code&gt;资源文件，或传入一个&lt;code&gt;View&lt;/code&gt;文件和一个用于提供参数的&lt;code&gt;LayoutParams&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;整个过程将从这个根&lt;code&gt;View&lt;/code&gt;开始，并遍历它的子&lt;code&gt;View&lt;/code&gt;来逐一绘制，每个&lt;code&gt;ViewGroup&lt;/code&gt;承担了要求它的子&lt;code&gt;View&lt;/code&gt;进行绘制的责任，每个&lt;code&gt;View&lt;/code&gt;承担了绘制自身的责任。并且父&lt;code&gt;View&lt;/code&gt;会在子&lt;code&gt;View&lt;/code&gt;完成绘制之前进行绘制，同级的&lt;code&gt;View&lt;/code&gt;将以它们出现在树中的顺序进行绘制。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;首先调用的当然是&lt;code&gt;View&lt;/code&gt;的构造函数，构造函数分为两种，一种供代码创建的&lt;code&gt;View&lt;/code&gt;使用，另一种是由&lt;code&gt;layout&lt;/code&gt;文件生成的&lt;code&gt;View&lt;/code&gt;使用，区别在于后者会从&lt;code&gt;layout&lt;/code&gt;文件中读入所有的属性，前者的属性则需要在代码中设置。&lt;/p&gt;
&lt;p&gt;另外后者在所有的子&lt;code&gt;View&lt;/code&gt;都生成完毕之后会回调&lt;code&gt;onFinishInflate&lt;/code&gt;方法。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在正式绘制之前要进行两个过程（布局机制[layout mechanism]）：&lt;/p&gt;
&lt;p&gt;首先是&lt;code&gt;measure&lt;/code&gt;过程。这是一个自顶向下的过程，父&lt;code&gt;View&lt;/code&gt;将期望尺寸传递给子&lt;code&gt;View&lt;/code&gt;，子&lt;code&gt;View&lt;/code&gt;需要根据这一信息确定自己的尺寸，并且保证这一尺寸满足父&lt;code&gt;View&lt;/code&gt;对其的要求，在子&lt;code&gt;View&lt;/code&gt;确定自己尺寸的过程中也要向它的子&lt;code&gt;View&lt;/code&gt;传递信息，就这样递归地确定自己的尺寸信息并储存在自身中，保证在&lt;code&gt;measure&lt;/code&gt;方法返回时，自身的尺寸信息已经确定。所以在根&lt;code&gt;View&lt;/code&gt;的&lt;code&gt;measure&lt;/code&gt;方法返回时，所有子&lt;code&gt;View&lt;/code&gt;的尺寸信息已经全部确定了。&lt;/p&gt;
&lt;p&gt;这个过程需要注意一个&lt;code&gt;View&lt;/code&gt;可能不止一次地调用&lt;code&gt;measure&lt;/code&gt;方法来对子&lt;code&gt;View&lt;/code&gt;进行测量。比如，可能要先传递一个无限制的信息来获取子&lt;code&gt;View&lt;/code&gt;想要的尺寸，当子&lt;code&gt;View&lt;/code&gt;希望的尺寸过大或过小时，父&lt;code&gt;View&lt;/code&gt;需要再次调用&lt;code&gt;measure&lt;/code&gt;方法来给予子&lt;code&gt;View&lt;/code&gt;一些限制。&lt;/p&gt;
&lt;p&gt;第二个是&lt;code&gt;layout&lt;/code&gt;过程，这也是一个自顶向下的遍历过程，在这个过程中父&lt;code&gt;View&lt;/code&gt;负责按照上一个过程中计算并储存在&lt;code&gt;View&lt;/code&gt;中的尺寸信息来正确地放置子&lt;code&gt;View&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同时这个过程可以通过调用&lt;code&gt;requestLayout()&lt;/code&gt;来重新进行，并且会引起后面步骤的执行，相当于对以这个&lt;code&gt;View&lt;/code&gt;为根的&lt;code&gt;View&lt;/code&gt;树进行重新布局。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面就是真正的绘制过程了，也就是&lt;code&gt;View&lt;/code&gt;的&lt;code&gt;draw()&lt;/code&gt;方法，在&lt;code&gt;draw()&lt;/code&gt;方法中，（如果需要）会&lt;strong&gt;依次&lt;/strong&gt;调用如下方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;drawBackground()&lt;/code&gt;：在画布上绘制特定的背景&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onDraw()&lt;/code&gt;：重写&lt;code&gt;View&lt;/code&gt;几乎必重写的一个方法，用于绘制图形&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatchDraw()&lt;/code&gt;：&lt;code&gt;ViewGroup&lt;/code&gt;会重写这个方法，用于对所有的子&lt;code&gt;View&lt;/code&gt;调用&lt;code&gt;draw()&lt;/code&gt;方法进行绘制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onDrawForeground()&lt;/code&gt;：用于绘制前景（如果需要）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看到如果需要调用上述的方法必定会按照这个顺序进行，也就是说，子&lt;code&gt;View&lt;/code&gt;的绘制是在父&lt;code&gt;View&lt;/code&gt;绘制之后进行的，而同级&lt;code&gt;View&lt;/code&gt;的绘制是根据&lt;code&gt;View&lt;/code&gt;在父&lt;code&gt;View&lt;/code&gt;中的顺序进行绘制的。&lt;/p&gt;
&lt;p&gt;同时这个过程可以通过调用&lt;code&gt;invalidate()&lt;/code&gt;来重新进行，相当于进行某个&lt;code&gt;View&lt;/code&gt;的重绘。&lt;/p&gt;</content><category term="Android"></category><category term="View"></category><category term="LifeCycle"></category></entry><entry><title>王爽汇编语言第三版实验</title><link href="/wang-shuang-hui-bian-yu-yan-di-san-ban-shi-yan.html" rel="alternate"></link><published>2017-03-09T11:42:37+08:00</published><updated>2017-03-09T11:42:37+08:00</updated><author><name>Zhihao Chen</name></author><id>tag:None,2017-03-09:/wang-shuang-hui-bian-yu-yan-di-san-ban-shi-yan.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;开学三周，王爽的《汇编语言》（第三版）总算是基本上看完了，本文是总结的第二部分，包括了书本上的实验&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;实验1 查看CPU和内存，用机器指令和汇编指令编程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用Debug，将下面的程序段写入内存，逐条执行，观察每条指令执行后，CPU中相关寄存器的变化。&lt;/li&gt;
&lt;/ol&gt;
&lt;!--more--&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style="text-align: center"&gt;机器码&lt;/th&gt;&lt;th style="text-align: center"&gt;汇编指令&lt;/th&gt;&lt;th style="text-align: center"&gt;执行后相关寄存器变化&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;b8 20 4e&lt;/td&gt;&lt;td style="text-align: center"&gt;mov ax, 4E20H&lt;/td&gt;&lt;td style="text-align: center"&gt;AX=4E20H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;05 16 14&lt;/td&gt;&lt;td style="text-align: center"&gt;add ax, 1416H&lt;/td&gt;&lt;td style="text-align: center"&gt;AX=6236H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;bb 00 20&lt;/td&gt;&lt;td style="text-align: center"&gt;mov bx, 2000H&lt;/td&gt;&lt;td style="text-align: center"&gt;BX=2000H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;01 d8&lt;/td&gt;&lt;td style="text-align: center"&gt;add ax, bx&lt;/td&gt;&lt;td style="text-align: center"&gt;AX=8236H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;89 …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;开学三周，王爽的《汇编语言》（第三版）总算是基本上看完了，本文是总结的第二部分，包括了书本上的实验&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;实验1 查看CPU和内存，用机器指令和汇编指令编程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用Debug，将下面的程序段写入内存，逐条执行，观察每条指令执行后，CPU中相关寄存器的变化。&lt;/li&gt;
&lt;/ol&gt;
&lt;!--more--&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style="text-align: center"&gt;机器码&lt;/th&gt;&lt;th style="text-align: center"&gt;汇编指令&lt;/th&gt;&lt;th style="text-align: center"&gt;执行后相关寄存器变化&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;b8 20 4e&lt;/td&gt;&lt;td style="text-align: center"&gt;mov ax, 4E20H&lt;/td&gt;&lt;td style="text-align: center"&gt;AX=4E20H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;05 16 14&lt;/td&gt;&lt;td style="text-align: center"&gt;add ax, 1416H&lt;/td&gt;&lt;td style="text-align: center"&gt;AX=6236H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;bb 00 20&lt;/td&gt;&lt;td style="text-align: center"&gt;mov bx, 2000H&lt;/td&gt;&lt;td style="text-align: center"&gt;BX=2000H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;01 d8&lt;/td&gt;&lt;td style="text-align: center"&gt;add ax, bx&lt;/td&gt;&lt;td style="text-align: center"&gt;AX=8236H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;89 c3&lt;/td&gt;&lt;td style="text-align: center"&gt;mov bx, ax&lt;/td&gt;&lt;td style="text-align: center"&gt;BX=8236H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;01 d8&lt;/td&gt;&lt;td style="text-align: center"&gt;add ax, bx&lt;/td&gt;&lt;td style="text-align: center"&gt;AX=046CH&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;b8 1a 00&lt;/td&gt;&lt;td style="text-align: center"&gt;mov ax, 001AH&lt;/td&gt;&lt;td style="text-align: center"&gt;AX=001AH&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;bb 26 00&lt;/td&gt;&lt;td style="text-align: center"&gt;mov bx, 0026H&lt;/td&gt;&lt;td style="text-align: center"&gt;BX=0026H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;00 d8&lt;/td&gt;&lt;td style="text-align: center"&gt;add al, bl&lt;/td&gt;&lt;td style="text-align: center"&gt;AX=0040H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;00 dc&lt;/td&gt;&lt;td style="text-align: center"&gt;add ah, bl&lt;/td&gt;&lt;td style="text-align: center"&gt;AX=2640H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;00 c7&lt;/td&gt;&lt;td style="text-align: center"&gt;add bh, al&lt;/td&gt;&lt;td style="text-align: center"&gt;BX=4026H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;b4 00&lt;/td&gt;&lt;td style="text-align: center"&gt;mov ah, 0&lt;/td&gt;&lt;td style="text-align: center"&gt;AX=0040H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;00 d8&lt;/td&gt;&lt;td style="text-align: center"&gt;add al, bl&lt;/td&gt;&lt;td style="text-align: center"&gt;AX=0066H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;04 9c&lt;/td&gt;&lt;td style="text-align: center"&gt;add al, 9CH&lt;/td&gt;&lt;td style="text-align: center"&gt;AX=0002H&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;提示，可用E命令和A命令以两种方式将指令写入内存。注意用T命令执行时，CS:IP的指向。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将下面3条指令写入从2000:0开始的内存单元中，利用这3条指令计算2的8次方。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov ax, 1
add ax, ax
jmp 2000:0003
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每次执行 add ax, ax 相当于将ax乘2，重复执行该条指令8次即可。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查看内存中的内容。
PC机主板上的ROM写有一个生产日期，在内存FFF00H～FFFFFH的某几个单元中，请找到这个生产日期并试图改变它。
提示，如果读者对实验的结果感到疑惑，请仔细阅读第1章中的1.15节。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过Debug中的D命令，可以观察到生产日期以MM/DD/YY的格式存储在内存的ffff:0005-ffff:000c共计8个字节处。
该生产日期不可被修改，因为其只读。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;向内存从B8100H开始的单元中填写数据，如：&lt;/p&gt;
&lt;p&gt;-e B810:0000 01 01 02 02 03 03 04 04&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;请读者先填写不同的数据，观察产生的现象；再改变填写的地址，观察产生的现象。
提示，如果读者对实验的结果感到疑惑，请仔细阅读第1章中的1.15节。&lt;/p&gt;
&lt;p&gt;通过向内存中的显存地址空间写入数据，控制在屏幕上的不同位置显示不同颜色的字符。&lt;/p&gt;
&lt;h2&gt;实验2 用机器指令和汇编指令编程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用Debug，将下面的程序段写入内存，逐条执行，根据指令执行后的实验运行情况填空。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov ax, ffff
mov ds, ax

mov ax, 2200
mov ss, ax

mov sp, 1000

mov ax,[0]  ;ax = _____
add ax,[2]  ;ax = _____
mov bx,[4]  ;bx = _____
add bx,[6]  ;bx = _____

push ax     ;sp = _____ 修改的内存单元的地址是_____内容为_____
push bx     ;sp = _____ 修改的内存单元的地址是_____内容为_____
pop ax      ;sp = _____ ax = _____
pop bx      ;sp = _____ bx = _____

push [4]    ;sp = _____ 修改的内存单元的地址是_____内容为_____
push [6]    ;sp = _____ 修改的内存单元的地址是_____内容为_____
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果（不唯一）:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;D4EA
25EE
3002
5F37
00FE 220FE 25EE
00FC 220FC 5F37
00FE 5F37
0100 25EE
00FE 220FE 3002
00FC 220FC 2F35
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;仔细观察图3.19中的实验过程，然后分析：为什么2000:0～2000:f中的内容会发生改变？
在使用T命令进行单步追踪的时候，产生了中断，为了保护现场，CPU将PSW、CS和IP依此入栈，导致了内存相关位置内容的改变。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;实验3 编程、编译、连接、跟踪&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;将下面的程序保存为t1.asm文件，将其生成可执行文件t1.exe。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:codesg

codesg segment
mov ax, 2000H
mov ss, ax
mov sp, 0
add sp, 10
pop ax
pop bx
push ax
push bx
pop ax
pop bx

mov ax, 4c00h
int 21h
codesg ends

end
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;edit t1.asm
masm.exe t1.asm;
link.exe t1.obj;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用Debug跟踪t1.exe的执行过程，写出每一步执行后，相关寄存器中的内容和栈顶的内容。
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style="text-align: center"&gt;汇编指令&lt;/th&gt;&lt;th style="text-align: center"&gt;相关寄存器的内容&lt;/th&gt;&lt;th style="text-align: center"&gt;栈顶的内容&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;mov ax, 2000H&lt;/td&gt;&lt;td style="text-align: center"&gt;AX = 2000H&lt;/td&gt;&lt;td style="text-align: center"&gt;00B8H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;mov ss, ax&lt;/td&gt;&lt;td style="text-align: center"&gt;SS = 2000H&lt;/td&gt;&lt;td style="text-align: center"&gt;-----&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;mov sp, 0&lt;/td&gt;&lt;td style="text-align: center"&gt;SP = 0&lt;/td&gt;&lt;td style="text-align: center"&gt;0000H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;add sp, 10&lt;/td&gt;&lt;td style="text-align: center"&gt;SP = 10&lt;/td&gt;&lt;td style="text-align: center"&gt;0000H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;pop ax&lt;/td&gt;&lt;td style="text-align: center"&gt;AX = 0 SP = 12&lt;/td&gt;&lt;td style="text-align: center"&gt;0000H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;pop bx&lt;/td&gt;&lt;td style="text-align: center"&gt;BX = 0 SP = 14&lt;/td&gt;&lt;td style="text-align: center"&gt;0000H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;push ax&lt;/td&gt;&lt;td style="text-align: center"&gt;SP = 12&lt;/td&gt;&lt;td style="text-align: center"&gt;0000H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;push bx&lt;/td&gt;&lt;td style="text-align: center"&gt;SP = 10&lt;/td&gt;&lt;td style="text-align: center"&gt;0000H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;pop ax&lt;/td&gt;&lt;td style="text-align: center"&gt;AX = 0 SP = 12&lt;/td&gt;&lt;td style="text-align: center"&gt;0000H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;pop bx&lt;/td&gt;&lt;td style="text-align: center"&gt;BX = 0 SP = 14&lt;/td&gt;&lt;td style="text-align: center"&gt;0000H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;mov ax, 4c00h&lt;/td&gt;&lt;td style="text-align: center"&gt;AX = 4C00H&lt;/td&gt;&lt;td style="text-align: center"&gt;0000H&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style="text-align: center"&gt;int 21h&lt;/td&gt;&lt;td style="text-align: center"&gt;-----&lt;/td&gt;&lt;td style="text-align: center"&gt;-----&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
结果不唯一&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PSP的头两个字节是CD 20，用Debug加载t1.exe，查看PSP的内容。&lt;/p&gt;
&lt;p&gt;-d 2119:0&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2119为CS-0010H&lt;/p&gt;
&lt;h2&gt;实验4 [bx]和loop的使用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编程，向内存0:200～0:23F依此传送数据0～63（3FH）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编程，向内存0:200～0:23F依此传送数据0～63（3FH），程序中只能使用9条指令，9条指令中包括“mov ax, 4c00h”和“int 21h”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code
code segment
mov ax, 0020h
mov ds, ax
mov bl, 0
mov cx, 64

s:      mov [bx], bl
inc bl
loop s

mov ax, 4c00h
int 21h
code ends
end
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;下面的程序的功能是将“mov ax, 4c00h”之前的指令复制到内存的0:200处，补全程序，上机调试，跟踪运行结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code
code segment
mov ax, _____
mov ds, ax
mov ax, 0020h
mov es, ax
mov bx, 0
mov cx, _____
s:      mov al, [bx]
mov es:[bx], al
inc bx
loop s
mov ax, 4c00h
int 21h
code ends
end
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;code
18H
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;提示：
复制的是什么？从哪里到哪里？
复制的是代码段中mov ax, 4c00h之前的代码，以数据的形式，从内存中代码段的位置复制到内存中0:200处开始的一段连续的空间。
复制的是什么？有多少个字节？你如何直到要复制的字节的数量？
可以用offset计算得出，也可以在Debug中用T命令观察得出。&lt;/p&gt;
&lt;h2&gt;实验5 编写、调试具有多个段的程序&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code, ds:data, ss:stack

data segment
dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h
data ends

stack segment
dw 0, 0, 0, 0, 0, 0, 0, 0
stack ends

code segment
start:  mov ax, stack
mov ss, ax
mov sp, 16

mov ax, data
mov ds, ax

push ds:[0]
push ds:[2]
pop ds:[2]
pop ds:[0]

mov ax, 4c00h
int 21h
code ends

end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;①CPU执行程序，程序返回前，data段中的数据为多少？
②CPU执行程序，程序返回前，CS = _____、SS = _____、DS = _____。
③设程序加载后，code段的段地址为X，则data段的段地址为_____，stack段的段地址为_____。
答案：
①data段中的数据不变。
②212B、212A、2129（答案不唯一）
③X-2、X-1&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code, ds:data, ss:stack

data segment
dw 0123h, 0456h
data ends

stack segment
dw 0, 0
stack ends

code segment
start:  mov ax, stack
mov ss, ax
mov sp, 16

mov ax, data
mov ds, ax

push ds:[0]
push ds:[2]
pop ds:[2]
pop ds:[0]

mov ax, 4c00h
int 21h
code ends

end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;①CPU执行程序，程序返回前，data段中的数据为多少？
②CPU执行程序，程序返回前，CS = _____、SS = _____、DS = _____。
③设程序加载后，code段的段地址为X，则data段的段地址为_____，stack段的段地址为_____。
④对于如下定义的段：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;name segment
...
segment ends
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为_____。
答案：
①data段中的数据不变。
②212B、212A、2129（答案不唯一）
③X-2、X-1
④((N-1)/16 + 1)*16 其中除法为整除&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code, ds:data, ss:stack

code segment
start:  mov ax, stack
mov ss, ax
mov sp, 16

mov ax, data
mov ds, ax

push ds:[0]
push ds:[2]
pop ds:[2]
pop ds:[0]

mov ax, 4c00h
int 21h
code ends

data segment
dw 0123h, 0456h
data ends

stack segment
dw 0, 0
stack ends

end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;①CPU执行程序，程序返回前，data段中的数据为多少？
②CPU执行程序，程序返回前，CS = _____、SS = _____、DS = _____。
③设程序加载后，code段的段地址为X，则data段的段地址为_____，stack段的段地址为_____。
答案：
①data段中的数据不变。
②2129、212D、212C（答案不唯一）
③X+3、X+4&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果将1. 2. 3.题中的最后一条伪指令“end start”改为“end”（也就是说，不指明程序的入口），则哪个程序仍然可以正确执行？请说明原因。
答案：
只有程序3可以正确运行，在不指明程序入口的情况下，程序默认按照顺序从头开始执行，而3个程序中只有程序3的code段位于最开始的部分，所以只有程序3可以正确运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序如下，编写code段中的代码，将a段和b段中的数据依此相加，将结果存到c段中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code
a segment
db 1, 2, 3, 4, 5, 6, 7, 8
a ends

b segment
db 1, 2, 3, 4, 5, 6, 7, 8
b ends

c segment
db 0, 0, 0, 0, 0, 0, 0, 0
c ends

code segment
start:
?
code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ds&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;es&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;cx&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;      &lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;al&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;al&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;es&lt;/span&gt;&lt;span class="o"&gt;:[&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="o"&gt;:[&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="o"&gt;],&lt;/span&gt; &lt;span class="n"&gt;al&lt;/span&gt;
&lt;span class="n"&gt;inc&lt;/span&gt; &lt;span class="n"&gt;bx&lt;/span&gt;
&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="n"&gt;c00h&lt;/span&gt;
&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;程序如下，编写code段中的代码，用push指令将a段中的前8个字型数据，逆序存储到b段中。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code

a segment
dw 1, 2, 3, 4, 5, 6, 7, 8, 9, 0ah, 0bh, 0ch, 0dh, 0eh, 0fh, 0ffh
a ends

b segment
dw 0, 0, 0, 0, 0, 0, 0, 0
b ends

code segment
start:  
?
code ends

end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ds&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;cx&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;      &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="n"&gt;c00h&lt;/span&gt;
&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;实验6 实践课程中的程序&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将课程中所有讲解过的程序上机调试，用Debug跟踪其执行过程，并在过程中进一步理解所讲内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编程，完成问题7.9中的程序。
程序如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:codesg, ss:stacksg, ds:datasg
stacksg segment
dw 0, 0, 0, 0, 0, 0, 0, 0
stacksg ends

datasg segment
db &amp;#39;1. display      &amp;#39;
db &amp;#39;2. brows        &amp;#39;
db &amp;#39;3. replace      &amp;#39;
db &amp;#39;4. modify       &amp;#39;
datasg ends

codesg segment
start:  mov ax, datasg
mov ds, ax
mov ax, stacksg
mov ss, ax
mov sp, 16
mov bx, 0
mov cx, 4
s:      push cx
mov cx, 4
mov si, 0
s0:     mov al, [bx + si + 3]
and al, 11011111b
mov [bx + si + 3], al
inc si
loop s0
add bx, 16
pop cx
loop s
mov ax, 4c00h
int 21h
codesg ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;实验7 寻址方式在结构化数据访问中的应用&lt;/h2&gt;
&lt;p&gt;编程，将data段中的数据按如下格式写入到table段中，并计算21年中的人均收入（取整），结果也按照下面的格式保存在table段中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:codesg, ss:stack

stack segment
dw 8 dup (0)
stack ends

data segment
db &amp;#39;1975&amp;#39;, &amp;#39;1976&amp;#39;, &amp;#39;1977&amp;#39;, &amp;#39;1978&amp;#39;, &amp;#39;1979&amp;#39;, &amp;#39;1980&amp;#39;, &amp;#39;1981&amp;#39;, &amp;#39;1982&amp;#39;, &amp;#39;1983&amp;#39;
db &amp;#39;1984&amp;#39;, &amp;#39;1985&amp;#39;, &amp;#39;1986&amp;#39;, &amp;#39;1987&amp;#39;, &amp;#39;1988&amp;#39;, &amp;#39;1989&amp;#39;, &amp;#39;1990&amp;#39;, &amp;#39;1991&amp;#39;, &amp;#39;1992&amp;#39;
db &amp;#39;1993&amp;#39;, &amp;#39;1994&amp;#39;, &amp;#39;1995&amp;#39;

dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514
dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000

dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226
dw 11542, 14430, 15257, 17800
data ends

table segment
db 21 dup (&amp;#39;year summ ne ?? &amp;#39;)
table ends

codesg segment
start:  mov ax, stack
mov ss, ax
mov sp, 16
mov ax, table
mov ds, ax
mov ax, data
mov es, ax
mov bx, 0
mov si, 0
mov cx, 21
year:   push cx
mov cx, 4
mov di, 0
char:   mov al, es:[si]
mov [bx+di], al
inc si
inc di
loop char
add bx, 16
pop cx
loop year
mov cx, 21
mov bx, 0
income: mov ax, es:[si]
mov [5+bx], ax
add si, 2
mov ax, es:[si]
mov [7+bx], ax
add si, 2
add bx, 16
loop income
mov cx, 21
mov bx, 0
staff:  mov ax, es:[si]
mov [10+bx], ax
add si, 2
add bx, 16
loop staff
mov cx, 21
mov bx, 0
average:mov ax, [bx+5]
mov dx, [bx+7]
div word ptr [bx+10]
mov [13+bx], ax
add bx, 16
loop average
mov ax, 4c00h
int 21h
codesg ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;实验8 分析一个奇怪的程序&lt;/h2&gt;
&lt;p&gt;分析下面的程序，在运行前思考，这个程序可以正确返回吗？
运行后再思考：为什么是这种结果？
通过这个程序加深对相关内容的理解。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:codesg
codesg segment
mov ax, 4c00h
int 21h
start: mov ax, 0
s:     nop
nop
mov di, offset s
mov si, offset s2
mov ax, cs:[si]
mov cs:[di], ax
s0:    jmp short s
s1:    mov ax, 0
int 21h
mov ax, 0
s2:    jmp short s1
nop
codesg ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;分析：
这个程序可以正确返回，程序的入口为mov ax, 0，注意到指令jmp short s1占2字节，于是指令mov di, offset s将s的偏移地址传送到寄存器DI，mov si, offset s2将s2的偏移地址传送到SI，然后再通过通用寄存器ax做中转将s2处的指令复制到s处，最后再跳转至s处执行复制过来的指令。
注意jmp short s1是相对跳转，其直接修改IP寄存器，从s2到s1共有8个字节的偏移，实际上 jmp short s1等价于(ip)=(ip)-8，通过Debug可知第一个nop指令的偏移地址为8，所以再执行了复制过的指令后，IP将指向0，程序按照顺序执行mov ax, 4c00h和int 21h，正确返回。&lt;/p&gt;
&lt;h2&gt;实验9 根据材料编程&lt;/h2&gt;
&lt;p&gt;编程：在屏幕中间分别显示绿色、绿底红色、白底蓝色的字符串'welcome to masm!'。
编程所需的只是通过阅读、分析下面的材料获得。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume ds:data, cs:code

data segment
db &amp;#39;welcome to masm!&amp;#39;
data ends

code segment
start:  mov ax, data
mov ds, ax
mov ax, 0B800H
mov es, ax

mov bx, 1664
mov si, 0
mov cx, 16
char1:  mov al, [si]
mov ah, 10000010B
mov es:[bx], ax
add bx, 2
inc si
loop char1

mov bx, 1824
mov si, 0
mov cx, 16
char2:  mov al, [si]
mov ah, 10100100B
mov es:[bx], ax
add bx, 2
inc si
loop char2

mov bx, 1984
mov si, 0
mov cx, 16
char3:  mov al, [si]
mov ah, 11110001B
mov es:[bx], ax
add bx, 2
inc si
loop char3

mov ax, 4C00H
int 21H
code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;实验10 编写子程序&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;显示字符串&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code, ss:stack

stack segment
dw 16 dup (0)
stack ends

data segment
db &amp;#39;Welcome to masm!&amp;#39;, 0
data ends

code segment
start:  mov dh, 8
mov dl, 3
mov cl, 2
mov ax, data
mov ds, ax
mov ax, stack
mov ss, ax
mov sp, 32
mov si, 0
call show_str

mov ax, 4c00h
int 21h

show_str:
push cx
push bx
push ax
push si
push di
push es
;using cx, bx, ax, si, di, es
mov ax, 0b800h
mov es, ax
mov bx, 0
mov di, 0
mov al, 160
mul dh
add bx, ax
mov al, 2
mul dl
add bx, ax ;bx stores address of start character
mov al, cl ;al stores the color of character
char:   mov ch, 0
mov cl, ds:[si]
jcxz zero
mov ch, al
mov es:[bx+di], cx
add di, 2
inc si
jmp char
zero:   pop es
pop di
pop si
pop ax
pop bx
pop cx
ret

code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;解决除法溢出的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code, ss:stack

stack segment
dw 16 dup (0)
stack ends

code segment
start:  mov ax, stack
mov ss, ax
mov sp, 32
mov ax, 4240h
mov dx, 000fh
mov cx, 0ah
call divdw

mov ax, 4c00h
int 21h

divdw:  push bx

mov bx, ax ; bx stores L
mov ax, dx ; ax stores H
mov dx, 0
div cx ; after div, ax holds int(H/N), dx holds rem(H/N)
push ax ; push int(H/N) temporarily
mov ax, bx ; ax stores L
div cx
mov cx, dx
pop dx

pop bx
ret

code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;数值显示&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code, ss:stack

stack segment
dw 16 dup (0)
stack ends

data segment
db 10 dup (0)
data ends

code segment
start:  mov ax, data
mov ds, ax
mov ax, stack
mov ss, ax
mov sp, 32
mov ax, 12666
mov si, 0
call dtoc

mov dh, 8
mov dl, 3
mov cl, 2
call show_str

mov ax, 4c00h
int 21h

dtoc:   push ax
push si
push di
push dx
push bx
push cx
mov di, 0
mov dx, 0
mov bx, 10

devide: mov cx, ax
jcxz stop
div bx
inc di
push dx
mov dx, 0
jmp devide
stop:   mov cx, di
string: pop bx
add bx, 30h
mov [si], bl
inc si
loop string

pop cx
pop bx
pop dx
pop di
pop si
pop ax
ret

show_str:
push cx
push bx
push ax
push si
push di
push es
;using cx, bx, ax, si, di, es
mov ax, 0b800h
mov es, ax
mov bx, 0
mov di, 0
mov al, 160
mul dh
add bx, ax
mov al, 2
mul dl
add bx, ax ;bx stores address of start character
mov al, cl ;al stores the color of character
char:   mov ch, 0
mov cl, ds:[si]
jcxz zero
mov ch, al
mov es:[bx+di], cx
add di, 2
inc si
jmp char
zero:   pop es
pop di
pop si
pop ax
pop bx
pop cx
ret

code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;实验11 编写子程序&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code

stack segment
dw 8 dup (0)
stack ends

data segment
db &amp;quot;Beginner&amp;#39;s All-purpose Symbolic Instruction Code.&amp;quot;, 0
data ends

code segment
begin:  mov ax, stack
mov ss, ax
mov sp, 16
mov ax, data
mov ds, ax
mov si, 0
call letterc

mov ax, 4c00h
int 21h

letterc:
push cx
push si
pushf

mov ch, 0
start:  mov cl, ds:[si]
jcxz zero
cmp cl, 97
jb next
cmp cl, 122
ja next
sub cl, 20h
mov ds:[si], cl
next:   inc si
jmp start

zero:   popf
pop si
pop cx
ret

code ends
end begin
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;实验12 编写0号中断的处理程序&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code

code segment
start:
mov ax, cs
mov ds, ax
mov si, offset do0

mov ax, 0
mov es, ax
mov di, 200h

mov cx, offset do0end - offset do0

cld

rep movsb

mov ax, 0
mov es, ax
mov word ptr es:[0], 200h
mov word ptr es:[2], 0

mov ax, 4c00h
int 21h

do0:
jmp short do0start
db &amp;quot;overflow!&amp;quot;
do0start:
mov ax, cs
mov ds, ax
mov si, 202h
mov ax, 0b800h
mov es, ax
mov di, 12*160+36*2
mov cx, 9
s:
mov al, [si]
mov es:[di], al
inc si
add di, 2
loop s

mov ax, 4c00h
int 21h
do0end:
nop

code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;实验13 编写、应用中断例程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;编写并安装int 7ch中断例程，功能为显示一个用0结束的字符串，中断例程安装在0:200处。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code

code segment
start:  mov ax, cs
mov ds, ax
mov si, offset print
mov ax, 0
mov es, ax
mov di, 200h
mov cx, offset printend - offset print
cld
rep movsb

mov ax, 0
mov es, ax
mov word ptr es:[7ch * 4], 200h
mov word ptr es:[7ch * 4 + 2], 0
mov ax, 4c00h
int 21h

print:
push es
push ax
push cx
push dx
push si
push di

mov ax, 0b800h
mov es, ax
mov al, 160
mov ah, 0
mul dh
mov di, ax
add dl, dl
mov dh, 0
add di, dx

mov al, cl
printstart:
mov ch, 0
mov cl, [si]
jcxz zero
mov ch, al
mov es:[di], cx
add di, 2
inc si
jmp printstart

zero:
pop di
pop si
pop dx
pop cx
pop ax
pop es
iret
printend:
nop

code ends

end start
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;编写并安装int 7ch中断例程，功能为完成loop指令功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code

code segment
start:  mov ax, cs
mov ds, ax
mov si, offset lp
mov ax, 0
mov es, ax
mov di, 200h
mov cx, offset lpend - offset lp
cld
rep movsb

mov ax, 0
mov es, ax
mov word ptr es:[7ch * 4], 200h
mov word ptr es:[7ch * 4 + 2], 0
mov ax, 4c00h
int 21h

lp:     push bp
mov bp, sp
dec cx
jcxz lpret
add [bp + 2], bx
lpret:  pop bp
iret
lpend:  nop

code ends

end start
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;下面的程序，分别在屏幕的第2、4、6、8行显示4句英文诗，补全程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code
code segment
s1:     db &amp;#39;Good,better,best,&amp;#39;, &amp;#39;$&amp;#39;
s2:     db &amp;#39;Never let it rest,&amp;#39;, &amp;#39;$&amp;#39;
s3:     db &amp;#39;Till good is better,&amp;#39;, &amp;#39;$&amp;#39;
s4:     db &amp;#39;And better,best.&amp;#39;, &amp;#39;$&amp;#39;
s:      dw offset s1, offset s2, offset s3, offset s4
row:    db 2, 4, 6, 8

start:  mov ax, cs
mov ds, ax
mov bx, offset s
mov si, offset row
mov cx, 4
ok:     mov bh, 0
mov dh, _____
mov dl, 0
mov ah, 2
int 10h

mov dx, _____
mov ah, 9
int 21h
_________
_________
loop ok
mov ax, 4c00h
int 21h
code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[si]&lt;/span&gt;
&lt;span class="k"&gt;[bx]&lt;/span&gt;
&lt;span class="na"&gt;add bx, 2&lt;/span&gt;
&lt;span class="na"&gt;inc si&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;实验14 访问CMOS RAM&lt;/h2&gt;
&lt;p&gt;编程，以"年/月/日 时:分:秒"的格式，显示当前的日期，时间。
注意：CMOS RAM中存储着系统的配置信息，出了保存时间信息的单元外，不要向其他的单元中写入内容，否则将引起一些系统错误。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code, ds:data

data segment
s db 9, 8, 7, 4, 2, 0
data ends
code segment
start:  mov ax, 0b800h
mov es, ax
mov di, 160 * 12
mov ax, data
mov ds, ax
mov si, 0
mov cx, 6

print:  mov al, s[si]
out 70h, al
in al, 71h
call number
cmp si, 2
jb slash
je space
cmp si, 5
jb colon
next:   inc si
loop print

mov ax, 4c00h
int 21h

;al-&amp;gt;number, es:di-&amp;gt;begin
number: push cx
mov ah, al
mov cl, 4
shr ah, cl
and al, 00001111b
add ah, 30h
add al, 30h
mov byte ptr es:[di], ah
mov byte ptr es:[di + 2], al
add di, 4
pop cx
ret

slash:  mov byte ptr es:[di], &amp;#39;\&amp;#39;
add di, 2
jmp next

colon:  mov byte ptr es:[di], &amp;#39;:&amp;#39;
add di, 2
jmp next

space:  mov byte ptr es:[di], &amp;#39; &amp;#39;
add di, 2
jmp next

code ends

end start
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;实验15 安装新的int 9中断例程&lt;/h2&gt;
&lt;p&gt;安装一个新的int 9中断例程，功能：在DOS下，按下'A'键后，除非不再松开，如果松开，就显示满屏幕的'A'；其他键照常处理。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code

stack segment
db 128 dup (0)
stack ends

code segment
start:  mov ax, stack
mov ss, ax
mov sp, 128

push cs
pop ds

mov ax, 0
mov es, ax

mov si, offset int9
mov di, 204h
mov cx, offset int9end - offset int9
cld
rep movsb

push es: [9 * 4]
pop es: [200h]
push es: [9 * 4 + 2]
pop es: [202h]

cli
mov word ptr es: [9 * 4], 204h
mov word ptr es: [9 * 4 + 2], 0
sti

mov ax, 4c00h
int 21h

int9:   push ax
push bx
push cx
push es

in al, 60h

pushf
call word ptr cs:[200h]

cmp al, 9eh
jne int9ret

mov ax, 0b800h
mov es, ax
mov bx, 0
mov cx, 2000
s:      mov byte ptr es:[bx], &amp;#39;A&amp;#39;
add bx, 2
loop s

int9ret:pop es
pop cx
pop bx
pop ax
iret

int9end:nop

code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;实验16 编写包含多个功能子程序的中断例程&lt;/h2&gt;
&lt;p&gt;安装一个新的int  7ch中断例程，为显示输出提供如下功能子程序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;清屏&lt;/li&gt;
&lt;li&gt;设置前景色&lt;/li&gt;
&lt;li&gt;设置背景色&lt;/li&gt;
&lt;li&gt;向上滚动一行&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code

code segment
start:  mov ax, cs
mov ds, ax
mov si, offset screen
mov ax, 0
mov es, ax
mov di, 200h
mov cx, offset screenend - offset screen
cld
rep movsb

mov ax, 0
mov es, ax
mov word ptr es:[7ch * 4], 200h
mov word ptr es:[7ch * 4 + 2], 0
mov ax, 4c00h
int 21h

screen: jmp short set
;考虑到安装中断例程后偏移地址发生了变化，需要重新计算相关的偏移地址
table   dw offset sub1 - offset screen + 200h, offset sub2 - offset screen + 200h, offset sub3 - offset screen + 200h, offset sub4 - offset screen + 200h

set:    push bx

cmp ah, 3
ja sret
mov bl, ah
mov bh, 0
add bx, bx

;同上
call word ptr cs:(table - screen + 200h)[bx]

sret:   pop bx
iret

sub1:   push bx
push cx
push es
mov bx, 0b800h
mov es, bx
mov bx, 0
mov cx, 2000
sub1s:  mov byte ptr es:[bx], &amp;#39; &amp;#39;
add bx, 2
loop sub1s
pop es
pop cx
pop bx
ret

sub2:   push bx
push cx
push es

mov bx, 0b800h
mov es, bx
mov bx, 1
mov cx, 2000
sub2s:  and byte ptr es:[bx], 11111000B
or es:[bx], al
add bx, 2
loop sub2s

pop es
pop cx
pop bx
ret

sub3:   push bx
push cx
push es
mov cl, 4
shl al, cl
mov bx, 0b800h
mov es, bx
mov bx, 1
mov cx, 2000
sub3s:  and byte ptr es:[bx], 10001111B
or es:[bx], al
add bx, 2
loop sub3s
pop es
pop cx
pop bx
ret

sub4:   push cx
push si
push di
push es
push ds

mov si, 0b800h
mov es, si
mov ds, si
mov si, 160
mov di, 0
cld
mov cx, 24
sub4s:  push cx
mov cx, 160
rep movsb
pop cx
loop sub4s

mov cx, 80
mov si, 0
sub4s1: mov byte ptr [160*24+si], &amp;#39; &amp;#39;
add si, 2
loop sub4s1

pop ds
pop es
pop di
pop si
pop cx
ret

screenend:
nop

code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参考&lt;a href="http://blog.csdn.net/lixiang0522/article/details/8434450"&gt;王爽《汇编语言》实验16：包含多个功能子程序的中断例程 解答&lt;/a&gt;
可以用伪指令org x简化该程序
org x表明接下来的指令从偏移地址x开始
修改后的相关指令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;org 200h
screen: jmp short set

table   dw sub1, sub2, sub3, sub4

set:    push bx

cmp ah, 3
ja sret
mov bl, ah
mov bh, 0
add bx, bx

call word ptr table[bx]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;实验17 编写包含多个功能子程序的中断例程&lt;/h2&gt;
&lt;p&gt;安装一个新的int 7ch中断例程，实现通过逻辑扇区号对软盘进行读写。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code

code segment
start:  mov ax, cs
mov ds, ax
mov si, offset floppyio
mov ax, 0
mov es, ax
mov di, 200h
mov cx, offset floppyioend - offset floppyio
cld
rep movsb

mov ax, 0
mov es, ax
mov word ptr es:[7ch * 4], 200h
mov word ptr es:[7ch * 4 + 2], 0
mov ax, 4c00h
int 21h

floppyio:
push ax
push cx
push dx

add ah, 2
mov al, 1
push ax ;计算相应的ah和al并压栈
mov ax, dx
mov dx, 0
mov cx, 1440
div cx ;计算逻辑扇区号/1440
push ax ;将商即面号压栈
mov ax, dx
mov dl, 18
div dl ;计算逻辑扇区号/1440的余数/18
inc ah
mov ch, al
mov cl, ah ;设置相应的ch和cl
pop ax ;将相应的面号出栈
mov dh, al
mov dl, 0 ;设置相应的dh和dl
pop ax ;将相应的ah和al出栈
int 13h ;调用13h例程进行实际的读写

pop dx
pop cx
pop ax
iret
floppyioend:
nop

code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;over&lt;/p&gt;</content><category term="汇编"></category><category term="实验"></category></entry><entry><title>王爽汇编语言第三版检测点答案</title><link href="/wang-shuang-hui-bian-yu-yan-di-san-ban-jian-ce-dian-da-an.html" rel="alternate"></link><published>2017-03-05T18:49:39+08:00</published><updated>2017-03-05T18:49:39+08:00</updated><author><name>Zhihao Chen</name></author><id>tag:None,2017-03-05:/wang-shuang-hui-bian-yu-yan-di-san-ban-jian-ce-dian-da-an.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;开学三周，王爽的《汇编语言》（第三版）总算是基本上看完了，本文是总结的第一部分，包括了书上所有的检测点答案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;第一章 基础知识&lt;/h2&gt;
&lt;h3&gt;检测点 1.1&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;1个CPU的寻址能力为8KB，那么它的地址总线的宽度为____。
    &lt;strong&gt;13&lt;/strong&gt;
    解析：CPU在内存中寻址的最小单位是Byte（字节），8KB = 2^13B，因此地址总线的宽度为13.&lt;/li&gt;
&lt;li&gt;1KB的存储器有____个存储单元。存储单元的编号从____到____。
    &lt;strong&gt;1024  0   1023&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;1KB的存储器可以存储____个bit，____个Byte。
    &lt;strong&gt;2^13  2^10&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;1GB、1MB、1KB分别是____________Byte
    &lt;strong&gt;2^30  2^20    2^10&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;8080、8088、80286、80386的地址总线宽度分别为16根、20根、24根、32根，则他们的寻址能力分别为____ …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;开学三周，王爽的《汇编语言》（第三版）总算是基本上看完了，本文是总结的第一部分，包括了书上所有的检测点答案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;第一章 基础知识&lt;/h2&gt;
&lt;h3&gt;检测点 1.1&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;1个CPU的寻址能力为8KB，那么它的地址总线的宽度为____。
    &lt;strong&gt;13&lt;/strong&gt;
    解析：CPU在内存中寻址的最小单位是Byte（字节），8KB = 2^13B，因此地址总线的宽度为13.&lt;/li&gt;
&lt;li&gt;1KB的存储器有____个存储单元。存储单元的编号从____到____。
    &lt;strong&gt;1024  0   1023&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;1KB的存储器可以存储____个bit，____个Byte。
    &lt;strong&gt;2^13  2^10&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;1GB、1MB、1KB分别是____________Byte
    &lt;strong&gt;2^30  2^20    2^10&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;8080、8088、80286、80386的地址总线宽度分别为16根、20根、24根、32根，则他们的寻址能力分别为____（KB）、____（MB）、____（MB）、____（GB）。
    &lt;strong&gt;64    1   16  4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根。则它们一次可以传送的数据为：____（B）、____（B）、____（B）、____（B）、____（B）。
    &lt;strong&gt;1 1   2   2   4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;从内存中读取1024字节的数据，8086至少要读取____次，80386至少要读取____次。
    &lt;strong&gt;512   256&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在存储器中，数据和程序以____形式存放。
    &lt;strong&gt;二进制&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;第二章 寄存器&lt;/h2&gt;
&lt;h3&gt;检测点 2.1&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;写出每条汇编指令执行后相关寄存器中的值&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov ax, 62627       AX =
mov ah, 31H     AX =
mov al, 23H     AX =
add ax, ax      AX =
mov bx, 826CH       BX =
mov cx, ax      CX =
mov ax, bx      AX =
add ax, bx      AX =
mov al, bh      AX =
mov ah, bl      AX =
add ah, ah      AX =
add al, 6       AX =
add al, al      AX =
mov ax, cx      AX =
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;F4A3H 31A3H   3123H 6246H 826CH   6246H   826CH   04D8H   0482H   6C82H   D882H   D888H   D810H   6246H&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只能使用目前学过的汇编指令，最多使用4条指令，编程计算2的4次方。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov ax, 2   
add ax, ax
add ax, ax
add ax, ax
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;检测点 2.2&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为_____到_____。
    &lt;strong&gt;00010H到1000FH&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;有一数据存放在内存20000H的单元中，现给定段地址为SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为_____，最大为_____。提示，反过来思考一下，当段地址给定为多少，CPU无论怎么变化偏移地址都无法寻到20000H单元？
    &lt;strong&gt;1001F 2000H&lt;/strong&gt;
    &lt;strong&gt;20000H - 0FFFFH = 10001H&lt;/strong&gt;
    &lt;strong&gt;20000H - 00000H = 20000H&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;检测点 2.3&lt;/h3&gt;
&lt;p&gt;下面的3条指令执行后，CPU几次修改IP？都是在什么时候？最后IP中的值是多少？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov ax, bx
sub ax, ax
jmp ax
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改了四次：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第1条指令执行后，IP指向第2条指令&lt;/li&gt;
&lt;li&gt;第2条指令执行后，IP指向第3条指令&lt;/li&gt;
&lt;li&gt;第3条指令执行后，IP指向第4条指令&lt;/li&gt;
&lt;li&gt;JMP指令执行后，IP重新指向第1条指令&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;第三章 寄存器（内存访问）&lt;/h2&gt;
&lt;h3&gt;检测点 3.1&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在Debug中，用“d 0:0 1f”查看内存，结果如下。&lt;/p&gt;
&lt;p&gt;0000:0000 70 80 F0 30 EF 60 30 E2-00 80 80 12 66 20 22 60
0000:0010 62 26 E6 D6 CC 2E 3C 3B-AB BA 00 00 26 06 66 88&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面的程序执行前，AX=0，BX=0，写出每条汇编指令执行完后相关寄存器中的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov ax, 1
mov ds, ax
mov ax, [0000]          AX = 
mov bx, [0001]          BX = 
mov ax, bx          AX = 
mov ax, [0000]          AX = 
mov bx, [0002]          BX =
add ax, bx          AX = 
add ax, [0004]          AX = 
mov ax, 0           AX = 
mov al, [0002]          AX = 
mov bx, 0           BX =
mov bl, [000C]          BX = 
add al, bl          AX = 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;提示，注意ds的设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2662H E626H   E626H   2662H   D6E6H   FD48H   2C14H   0   00E6H   0   0026H   000CH&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存中的情况如图3.6所示。
    各寄存器的初始值：CS=2000H，IP=0，DS=1000H，AX=0，BX=0；
    ①写出CPU执行的指令序列（用汇编指令写出）
    ②写出CPU执行每条指令后，CS、IP和相关寄存器中的数值。
    ③再次体会：数据和程序有区别吗？如何确定内存中的信息哪些是数据，哪些是程序？&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;指令&lt;/th&gt;
&lt;th align="center"&gt;CS:IP&lt;/th&gt;
&lt;th align="center"&gt;DS&lt;/th&gt;
&lt;th align="center"&gt;AX&lt;/th&gt;
&lt;th align="center"&gt;BX&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;mov ax, 6622H&lt;/td&gt;
&lt;td align="center"&gt;2000:3&lt;/td&gt;
&lt;td align="center"&gt;1000H&lt;/td&gt;
&lt;td align="center"&gt;6622H&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;jmp 0ff0:0100&lt;/td&gt;
&lt;td align="center"&gt;2000:8-&amp;gt;1000:0&lt;/td&gt;
&lt;td align="center"&gt;1000H&lt;/td&gt;
&lt;td align="center"&gt;6622H&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;mov ax, 2000H&lt;/td&gt;
&lt;td align="center"&gt;1000:3&lt;/td&gt;
&lt;td align="center"&gt;1000H&lt;/td&gt;
&lt;td align="center"&gt;2000H&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;mov ds, ax&lt;/td&gt;
&lt;td align="center"&gt;1000:5&lt;/td&gt;
&lt;td align="center"&gt;2000H&lt;/td&gt;
&lt;td align="center"&gt;2000H&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;mov ax, [0008]&lt;/td&gt;
&lt;td align="center"&gt;1000:8&lt;/td&gt;
&lt;td align="center"&gt;2000H&lt;/td&gt;
&lt;td align="center"&gt;C389H&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;mov ax, [0002]&lt;/td&gt;
&lt;td align="center"&gt;1000:B&lt;/td&gt;
&lt;td align="center"&gt;2000H&lt;/td&gt;
&lt;td align="center"&gt;EA66H&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;程序和数据没有区别，本质上都是二进制01码，关键在于CPU如何解读。&lt;/p&gt;
&lt;h3&gt;检测点 3.2&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;补全下面的程序，使其可以将10000H～1000FH中的8个字，逆序复制到20000H～2000FH中。逆序复制的含义如图3.17所示（图中内存里的数据均为假设）。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov ax, 1000H
mov ds, ax
__________
__________
__________
push [0]
push [2]
push [4]
push [6]
push [8]
push [A]
push [C]
push [E]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov ax, 2000H
mov ss, ax
mov sp, 0010H
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;补全下面的程序，使其可以将10000H～1000FH中的8个字，逆序复制到20000H～2000FH中。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov ax, 2000H
mov ds, ax
__________
__________
__________
pop [E]
pop [C]
pop [A]
pop [8]
pop [6]
pop [4]
pop [2]
pop [0]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov ax, 1000H
mov ss, ax
mov sp, 0
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;第六章 包含多个段的程序&lt;/h2&gt;
&lt;h3&gt;检测点 6.1&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;下面的程序实现依此用内存0:0-0:15单元中的内容改写程序中的数据，完成程序：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:codesg

codesg segment
    dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h

start:  mov ax, 0
    mov ds, ax
    mov bx, 0

    mov cx, 8
s:  mov ax, [bx]
    _________
    add bx, 2
    loop s

    mov ax, 4c00h
    int 21h

codesg ends

end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov cs:[bx], ax
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;下面的程序实现依此用内存0:0-0:15单元中的内容改写程序中的数据，数据的传送用栈来进行。栈空间设置在程序内。完成程序：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:codesg
    dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h

    dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

start:  mov ax, ____
    mov ss, ax
    mov sp, ____

    mov ax, 0
    mov ds, ax
    mov bx, 0
    mov cx, 8
s:  push [bx]
    ____________
    add bx, 2
    loop s

    mov ax, 4c00h
    int 21h

codesg ends

end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0
24h
pop cs:[bx]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;第九章 转移指令的原理&lt;/h2&gt;
&lt;h3&gt;检测点 9.1&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;程序如下&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code

data segment
    ___________
data ends

code segment
start:  mov ax, data
    mov ds, ax
    mov bx, 0
    jmp word ptr [bx+1]

code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;若要使程序中的jmp指令执行后，CS:IP指向程序的第一条指令，在data段中应该定义哪些数据？
答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dw 0, 0
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;程序如下&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code

data segment
    dd 12345678H
data ends

code segment

start:  mov ax, data
    mov ds, ax
    mov bx, 0
    mov [bx], ____
    mov [bx + 2], ____
    jmp dword ptr ds:[0]

code ends

end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;补全程序，使jmp指令执行后，CS:IP指向程序的第一条指令。
答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bx
cs
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：bx指向低位，bx+2指向高位，低位为IP，而高位为CS。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用Debug查看内存，结果如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="n"&gt;BE&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;06&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt; &lt;span class="o"&gt;......&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;则此时，CPU执行指令后，(CS)=?，(IP)=?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov ax, 2000H
mov es, ax
jmp dword ptr es:[1000H]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案：
(CS)=0006，(IP)=00BE&lt;/p&gt;
&lt;h3&gt;检测点 9.2&lt;/h3&gt;
&lt;p&gt;补全编程，利用jcxz指令，实现在内存2000H段中查找第一个值为0的字节，找到后，将它的偏移地址存储在dx中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code
code segment
start:  mov ax, 2000H
    mov ds, ax
    mov bx, 0
s:  __________
    __________
    __________
    __________
    jmp short s
ok: mov dx, bx
    mov ax, 4c00h
    int 21h
code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov cl, [bx]
mov ch, 0 ;注意这一步的必要性
jcxz ok
inc bx
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;检测点 9.3&lt;/h3&gt;
&lt;p&gt;补全编程，利用loop指令，实现在内存的2000H段中查找第一个值为0的字节，找到后，将它的偏移地址存储在dx中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code
code segment
start:  mov ax, 2000H
    mov ds, ax
    mov bx, 0
s:  mov cl, [bx]
    mov ch, 0
    _________
    inc bx
    loop s
ok: dec bx
    mov dx, bx
    mov ax, 4c00h
    int 21h
code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inc cx ;注意loop的工作原理
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;第十章 CALL和RET指令&lt;/h2&gt;
&lt;h3&gt;检测点 10.1&lt;/h3&gt;
&lt;p&gt;补全程序，实现从内存1000：0000处开始执行指令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code

stack segment
    db 16 dup (0)
stack ends

code segment
start:  mov ax,stack
    mov ss,ax
    mov sp,16
    mov ax, ____
    push ax
    mov ax, ____ 
    push ax
    retf
code ends

end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1000h
0
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;检测点 10.2&lt;/h3&gt;
&lt;p&gt;下面的程序执行后，ax中的数值为多少？&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;内存地址&lt;/th&gt;
&lt;th align="center"&gt;机器码&lt;/th&gt;
&lt;th align="center"&gt;汇编指令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1000:0&lt;/td&gt;
&lt;td align="center"&gt;b8 00 00&lt;/td&gt;
&lt;td align="center"&gt;mov ax,0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1000:3&lt;/td&gt;
&lt;td align="center"&gt;e8 01 00&lt;/td&gt;
&lt;td align="center"&gt;call s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1000:6&lt;/td&gt;
&lt;td align="center"&gt;40&lt;/td&gt;
&lt;td align="center"&gt;inc ax&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1000:7&lt;/td&gt;
&lt;td align="center"&gt;58&lt;/td&gt;
&lt;td align="center"&gt;s:   pop ax&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ax中的数值为6，注意执行完call s后，IP先变为6，然后将IP的值压栈，最后跳转至s。&lt;/p&gt;
&lt;h3&gt;检测点 10.3&lt;/h3&gt;
&lt;p&gt;下面的程序执行后，ax中的数值为多少？&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;内存地址&lt;/th&gt;
&lt;th align="center"&gt;机器码&lt;/th&gt;
&lt;th align="center"&gt;汇编指令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1000:0&lt;/td&gt;
&lt;td align="center"&gt;b8 00 00&lt;/td&gt;
&lt;td align="center"&gt;mov ax,0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1000:3&lt;/td&gt;
&lt;td align="center"&gt;9a 09 00 00 10&lt;/td&gt;
&lt;td align="center"&gt;call far ptr s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1000:8&lt;/td&gt;
&lt;td align="center"&gt;40&lt;/td&gt;
&lt;td align="center"&gt;inc ax&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1000:9&lt;/td&gt;
&lt;td align="center"&gt;58&lt;/td&gt;
&lt;td align="center"&gt;s:   pop ax&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;add ax,ax&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;pop bx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;add ax,bx&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ax中的数值为1010H，注意执行完call far ptr s后，IP先变为8，然后将CS、IP的值分别为1000和8依此压栈，最后再跳转至s继续执行。&lt;/p&gt;
&lt;h3&gt;检测点 10.4&lt;/h3&gt;
&lt;p&gt;下面的程序执行后，ax中的数值为多少？&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;内存地址&lt;/th&gt;
&lt;th align="center"&gt;机器码&lt;/th&gt;
&lt;th align="center"&gt;汇编指令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1000:0&lt;/td&gt;
&lt;td align="center"&gt;b8 06 00&lt;/td&gt;
&lt;td align="center"&gt;mov ax,6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1000:3&lt;/td&gt;
&lt;td align="center"&gt;ff d0&lt;/td&gt;
&lt;td align="center"&gt;call ax&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1000:5&lt;/td&gt;
&lt;td align="center"&gt;40&lt;/td&gt;
&lt;td align="center"&gt;inc ax&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1000:6&lt;/td&gt;
&lt;td align="center"&gt;58&lt;/td&gt;
&lt;td align="center"&gt;mov bp,sp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;add ax,[bp]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ax中的数值为0BH，分析方法类似检测点10.2&lt;/p&gt;
&lt;h3&gt;检测点 10.5&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;下面的程序执行后，ax中的数值为多少？&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code
stack segment
    dw 8 dup (0)
stack ends
code segment
start:  mov ax,stack
    mov ss,ax
    mov sp,16
    mov ds,ax
    mov ax,0
    call word ptr ds:[0eh]
    inc ax
    inc ax
    inc ax
    mov ax,4c00h
    int 21h
code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ax中的数值为3，注意ds与ss中存放的段地址相同，在执行了call word ptr ds:[0EH]之后，程序会先将下一条指令inc ax的偏移量压栈，然后跳转到栈顶所指向的指令的位置，即跳转至第一条inc ax的位置，故最后ax的值为3。&lt;/p&gt;
&lt;p&gt;注意：在使用Debug单步跟踪的时候，由于t命令所导致的中断，而影响了栈中的值。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下面的程序执行后，ax和bx中的数值为多少？&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:codesg
data segment
    dw 8 dup (0)
data ends
code segment
start:  mov ax,data
    mov ss,ax
    mov sp,16
    mov word ptr ss:[0],offset s
    mov ss:[2],cs
    call dword ptr ss:[0]
    nop
s:  mov ax,offset s
    sub ax,ss:[0ch]     
    mov bx,cs
    sub bx,ss:[0eh]
    mov ax,4c00h
    int 21h
code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ax中的数值为1，bx中的数值为0，注意到程序的一开始将a的偏移量和cs放入ss:[0]和ss:[2]中，然后调用call指令，将CS和IP(nop指令的偏移量)依此压栈后跳转到s处继续执行，ax最终为s的偏移量减去nop指令所在位置的偏移量，为1，bx最终为cs的段地址相减，为0。&lt;/p&gt;
&lt;h2&gt;第十一章 标志寄存器&lt;/h2&gt;
&lt;h3&gt;检测点 11.1&lt;/h3&gt;
&lt;p&gt;写出下面每条指令执行后，ZF、PF、SF等标志位的值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;指令&lt;/th&gt;
&lt;th align="center"&gt;ZF&lt;/th&gt;
&lt;th align="center"&gt;PF&lt;/th&gt;
&lt;th align="center"&gt;SF&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;sub al, al&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;mov al, 1&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;push ax&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;pop bx&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;add al, bl&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;add bl, 10&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;mul al&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;检测点 11.2&lt;/h3&gt;
&lt;p&gt;写出下面每条指令执行后，ZF、PF、SF、CF、OF等标志位的值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;指令&lt;/th&gt;
&lt;th align="center"&gt;CF&lt;/th&gt;
&lt;th align="center"&gt;OF&lt;/th&gt;
&lt;th align="center"&gt;SF&lt;/th&gt;
&lt;th align="center"&gt;ZF&lt;/th&gt;
&lt;th align="center"&gt;PF&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;sub al, al&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;mov al, 10H&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;add al, 90H&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;mov al, 80H&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;add al, 80H&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;mov al, 0FCH&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;add al, 05H&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;mov al, 7DH&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;add al, 0BH&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;检测点 11.3&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;补全下面的程序，统计F000:0处32个字节中，大小在[32,128]的数据的个数。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    mov ax, 0f000h
    mov ds, ax

    mov bx, 0
    mov dx, 0
    mov cx, 32
s:  mov al, [bx]
    cmp al, 32
    __________
    cmp al, 128
    __________
    inc dx
s0: inc bx
    loop s
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;jb s0
ja s0
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;补全下面的程序，统计F000:0处32个字节中，大小在(32,128)的数据的个数。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    mov ax, 0f000h
    mov ds, ax

    mov bx, 0
    mov dx, 0
    mov cx, 32
s:  mov al, [bx]
    cmp al, 32
    __________
    cmp al, 128
    __________
    inc dx
    s0: inc bx
    loop s
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;jna s0
jnb s0
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;检测点 11.4&lt;/h3&gt;
&lt;p&gt;下面的程序执行后：(ax)=?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov ax, 0
push ax
popf ;将PSW置0(本章所学习的标志位都为0)
mov ax, 0fff0h
add ax, 0010h ;修改相关标志位
pushf
pop ax ;(将PSW保存至ax)
and al, 11000101B
and ah, 00001000B ;只考虑CF,PF,ZF,SF,OF五个标志位
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案：
(ax)=45H&lt;/p&gt;
&lt;h2&gt;第十二章 内中断&lt;/h2&gt;
&lt;h3&gt;检测点 12.1&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;用Debug查看内存，情况如下：
    0000:0000 68 10 A7 00 8B 01 70 00-16 00 9D 03 8B 01 70 00
    则3号中断源对应的中断处理程序的入口地址为：&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;_____&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;p&gt;0070:018B&lt;/p&gt;
&lt;p&gt;注意高地址存放段地址，低地址存放偏移地址&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存储N号中断源对应的中断处理程序入口的偏移地址的内存单元的地址为：&lt;strong&gt;&lt;em&gt;_
    存储N号中断源对应的中断处理程序入口的段地址的内存单元的地址为：&lt;/em&gt;&lt;/strong&gt;_&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答案：4N，4N+2&lt;/p&gt;
&lt;h2&gt;第十三章 int指令&lt;/h2&gt;
&lt;h3&gt;检测点 13.1&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在上面的内容中，我们用7ch中断例程实现loop的功能，则上面的7ch中断例程所能进行的最大转移位移为多少？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答案：65535&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用7ch中断例程完成jmp near ptr s指令的功能，用bx向中断例程传送转移位移。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;jnp&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;bp&lt;/span&gt;
    &lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sp&lt;/span&gt;
    &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;],&lt;/span&gt; &lt;span class="n"&gt;bx&lt;/span&gt;
    &lt;span class="n"&gt;pop&lt;/span&gt; &lt;span class="n"&gt;bp&lt;/span&gt;
    &lt;span class="n"&gt;iret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;检测点 13.2&lt;/h3&gt;
&lt;p&gt;判断下面说法的正误：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们可以编程改变FFFF:0处的指令，使得CPU不去执行BIOS中的硬件系统检测和初始化程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;错误：FFFF:0处的内容无法修改&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;int 19h中断例程，可以由DOS提供。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;错误：此时DOS还未被引导&lt;/p&gt;
&lt;h2&gt;第十四章 端口&lt;/h2&gt;
&lt;h3&gt;检测点 14.1&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;编程，读取CMOS RAM的2号单元的内容。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov al, 2
out 70h, 2
in al, 71h
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;编程，向CMOS RAM的2号单元写入0。 &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov al, 2
out 70h, 2
mov al, 0
out 71h, al
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;检测点 14.2&lt;/h3&gt;
&lt;p&gt;编程，用加法和位移指令计算(ax)=(ax)*10。
提示，(ax)*10=(ax)*2+(ax)*8。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov bx, ax
shl ax, 1
mov cl, 3
shl bx, cx
add ax, bx
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;第十五章 外中断&lt;/h2&gt;
&lt;h3&gt;检测点 15.1&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;仔细分析一下上面的int 9中断例程，看看是否可以精简一下？
    其实在我们的int 9中断例程中，模拟int指令调用原int 9中断例程的程序段是可以精简的，因为在进入中断例程后，IF和TF都已经置0，没有必要再进行设置了。对于程序段：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pushf
pushf
pop ax
and ah, 11111100B
push ax
popf
call dword ptr ds:[0]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以精简为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pushf
call dword ptr ds:[0]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;两条指令。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仔细分析上面程序中的主程序，看看有什么潜在的问题？
    在主程序中，如果在执行设置int 9中断例程的段地址和偏移地址的指令之间发生了键盘中断，则CPU将转去一个错误的地址执行，将发生错误。
    找出这样的程序段，改写它们，排除潜在的问题。
    提示，注意sti和cli指令的用法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cli
mov word ptr es:[9*4],offset int9
mov word ptr es:[9*4+2],cs
sti
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以及：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cli
push ds:[0]
pop es:[9*4]
push ds:[2]
pop es:[9*4+2]
sti
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;第十六章 直接定址表&lt;/h2&gt;
&lt;h3&gt;检测点 16.1&lt;/h3&gt;
&lt;p&gt;下面的程序将code段中a处的8个数据累加，结果存储到b处的双字中，补全程序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code
code segment
    a dw 1, 2, 3, 4, 5, 6, 7, 8
    b dd 0
start:  mov si, 0
    mov cx, 8
s:  mov ax, ____
    add ____, ax
    adc ____, 0
    add si, ____
    loop s

    mov ax, 4c00h
    int 21h

code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a[si]
word ptr b[0]
word ptr b[2]
2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意word ptr的使用&lt;/p&gt;
&lt;h3&gt;检测点 16.2&lt;/h3&gt;
&lt;p&gt;下面的程序将data段中a处的8个数据累加，结果存储到b处的字中，补全程序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;assume cs:code, es:data

data segment
a   db 1, 2, 3, 4, 5, 6, 7, 8
b   dw 0
data ends

code segment
start:  __________
    __________
    mov si, 0
    mov cx, 8
s:  mov al, a[si]
    mov ah, 0
    add b, ax
    inc si
    loop s

    mov ax, 4c00h
    int 21h
code ends
end start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;答案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mov ax, data
mov es, ax
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;第十七章 使用BIOS进行键盘输入和磁盘读写&lt;/h2&gt;
&lt;h3&gt;检测点 17.1&lt;/h3&gt;
&lt;p&gt;“在int 16h中断例程中，一定有设置IF=1的指令”，这种说法对吗？&lt;/p&gt;
&lt;p&gt;正确，int 16h中断例程在键盘缓冲区中没有数据时，会等待直到键盘缓冲区中有数据为止，因此，int 16h中需要处理int 9h中断，所以一定有设置IF=1的指令。&lt;/p&gt;
&lt;p&gt;over&lt;/p&gt;</content><category term="答案"></category><category term="汇编"></category></entry><entry><title>Java泛型中List、List&lt;Object&gt;、List&lt;?&gt;的区别</title><link href="/javafan-xing-zhong-list-listobject-listde-qu-bie.html" rel="alternate"></link><published>2017-02-14T16:30:00+08:00</published><updated>2017-02-14T16:30:00+08:00</updated><author><name>Di Wu</name></author><id>tag:None,2017-02-14:/javafan-xing-zhong-list-listobject-listde-qu-bie.html</id><summary type="html">&lt;p&gt;Java 1.5中引入了泛型的概念以增加代码的安全性与清晰度，同时为了提供对旧代码的兼容性，让旧代码不经过改动也可以在新版本中运行，Java提供了原生态类型（或称原始类型）。但是实际中在新的代码中已经不应该使用原生态类型。&lt;/p&gt;
&lt;p&gt;原生态类型的含义是不带任何实际参数的泛型名称，例如Java 1.5后改为泛型实现的&lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;，&lt;code&gt;List&lt;/code&gt;就是它的原生态类型，与没有引入泛型之前的类型完全一致。&lt;/p&gt;
&lt;p&gt;而在虚拟机层面上，是没有泛型这一概念的——所有对象都属于普通类。在编译时，所有的泛型类都会被视为原生态类型。&lt;/p&gt;
&lt;p&gt;那么为什么不应该使用原生态类型呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。——Effective Java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;泛型的目的简单地说就是可以让一些运行时才能发现的错误可以在编译期间就可以被编译器所检测出，运行时出问题的代价与编译期出现问题的代价的差别可想而知。换句话说，泛型是编译器的一种及时发现错误的机制，同时也给用户带来了代码的清晰与简洁的附加好处（不必再写一些复杂而危险并且不直观的强制类型转换）。&lt;/p&gt;
&lt;p&gt;下面就进入正题谈谈以&lt;code&gt;List&lt;/code&gt;为例时&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;、&lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;的区别。&lt;/p&gt;
&lt;p&gt;先下定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;List&lt;/code&gt;：&lt;strong&gt;原生态类型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;：&lt;strong&gt;参数化的类型&lt;/strong&gt;，表明&lt;code&gt;List&lt;/code&gt;中可以 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Java 1.5中引入了泛型的概念以增加代码的安全性与清晰度，同时为了提供对旧代码的兼容性，让旧代码不经过改动也可以在新版本中运行，Java提供了原生态类型（或称原始类型）。但是实际中在新的代码中已经不应该使用原生态类型。&lt;/p&gt;
&lt;p&gt;原生态类型的含义是不带任何实际参数的泛型名称，例如Java 1.5后改为泛型实现的&lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;，&lt;code&gt;List&lt;/code&gt;就是它的原生态类型，与没有引入泛型之前的类型完全一致。&lt;/p&gt;
&lt;p&gt;而在虚拟机层面上，是没有泛型这一概念的——所有对象都属于普通类。在编译时，所有的泛型类都会被视为原生态类型。&lt;/p&gt;
&lt;p&gt;那么为什么不应该使用原生态类型呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。——Effective Java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;泛型的目的简单地说就是可以让一些运行时才能发现的错误可以在编译期间就可以被编译器所检测出，运行时出问题的代价与编译期出现问题的代价的差别可想而知。换句话说，泛型是编译器的一种及时发现错误的机制，同时也给用户带来了代码的清晰与简洁的附加好处（不必再写一些复杂而危险并且不直观的强制类型转换）。&lt;/p&gt;
&lt;p&gt;下面就进入正题谈谈以&lt;code&gt;List&lt;/code&gt;为例时&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;、&lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;的区别。&lt;/p&gt;
&lt;p&gt;先下定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;List&lt;/code&gt;：&lt;strong&gt;原生态类型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;：&lt;strong&gt;参数化的类型&lt;/strong&gt;，表明&lt;code&gt;List&lt;/code&gt;中可以&lt;strong&gt;容纳&lt;/strong&gt;任意类型的对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;：&lt;strong&gt;无限定通配符类型&lt;/strong&gt;，表示&lt;strong&gt;只能包含某一种未知对象类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面看一段代码：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DiffInGeneric&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;strings&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strings&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//ok&lt;/span&gt;
        &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;objects&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strings&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="c1"&gt;//Error: java: incompatible types: java.util.List&amp;lt;java.lang.String&amp;gt; cannot be converted to java.util.List&amp;lt;java.lang.Object&amp;gt;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;我们创建了一个&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;类型的对象&lt;code&gt;strings&lt;/code&gt;，再把它赋给原生态类型&lt;code&gt;List&lt;/code&gt;，这是可以的。但是第5行中尝试把它传递给&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;时，出现了一个类型不相容错误，注意，这是一个编译期错误。&lt;/p&gt;
&lt;p&gt;这是因为泛型有子类型化的规则：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;是原生态类型&lt;code&gt;List&lt;/code&gt;的一个子类型。虽然&lt;code&gt;String&lt;/code&gt;是&lt;code&gt;Object&lt;/code&gt;的子类型，但是由于&lt;strong&gt;泛型是不可协变的&lt;/strong&gt;，&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;并不是&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;的子类型，所以这里的传递无法通过编译。&lt;/p&gt;
&lt;p&gt;如果像上面那样使用原生态类型会有什么隐患呢？看下面一段代码：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DiffInGeneric&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;strings&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class="n"&gt;unsafeAdd&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strings&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strings&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;unsafeAdd&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;编译器提示了两条警告：&lt;/p&gt;
&lt;p&gt;第8行：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;warning: &lt;span class="o"&gt;[&lt;/span&gt;rawtypes&lt;span class="o"&gt;]&lt;/span&gt; found raw type: List
private static void unsafeAdd&lt;span class="o"&gt;(&lt;/span&gt;List list, Object object&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                              ^
missing &lt;span class="nb"&gt;type&lt;/span&gt; arguments &lt;span class="k"&gt;for&lt;/span&gt; generic class List&amp;lt;E&amp;gt;
where E is a type-variable:
    E extends Object declared in interface List
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;警告发现了原生态类型&lt;code&gt;List&lt;/code&gt;，同时还贴心地指出了&lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;的形式以及&lt;code&gt;E&lt;/code&gt;的来源。&lt;/p&gt;
&lt;p&gt;第9行：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;warning: &lt;span class="o"&gt;[&lt;/span&gt;unchecked&lt;span class="o"&gt;]&lt;/span&gt; unchecked call to add&lt;span class="o"&gt;(&lt;/span&gt;E&lt;span class="o"&gt;)&lt;/span&gt; as a member of the raw &lt;span class="nb"&gt;type&lt;/span&gt; List
        list.add&lt;span class="o"&gt;(&lt;/span&gt;object&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                ^
 where E is a type-variable:
    E extends Object declared in interface List
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;同样指出了我们正在把一个对象添加到&lt;code&gt;List&lt;/code&gt;中，而这个添加过程由于我们使用了原生态类型而无法被检验。&lt;/p&gt;
&lt;p&gt;如果忽略这两条警告并运行这个程序，显然会出现一条错误：&lt;/p&gt;
&lt;p&gt;第5行： &lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;thread&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;main&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lang&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ClassCastException&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lang&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Integer&lt;/span&gt; &lt;span class="n"&gt;cannot&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;cast&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lang&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;String&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;我们试图把一个自动装箱后的&lt;code&gt;Integer&lt;/code&gt;对象插入到了一个被声明为&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;的&lt;code&gt;List&lt;/code&gt;中，由于我们在&lt;code&gt;unsafeAdd&lt;/code&gt;方法中使用了原生态类型，从而使得编译器无法在编译期间检查&lt;code&gt;add&lt;/code&gt;参数的合法性，从而没有产生编译错误而是产生了一条警告，运行后当试图把这个错误的&lt;code&gt;Integer&lt;/code&gt;对象作为&lt;code&gt;String&lt;/code&gt;取出时就会出现&lt;code&gt;ClassCaseException&lt;/code&gt;异常，这是个运行时的异常，导致了程序中断。&lt;/p&gt;
&lt;p&gt;如果我们把&lt;code&gt;unsafeAdd&lt;/code&gt;方法的参数从&lt;code&gt;List&lt;/code&gt;改为&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;会发生什么呢？正如之前所说的那样，由于&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;并不是&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;的子类型，所以在传递参数的时候就会出现第一段代码中出现的&lt;strong&gt;编译期错误&lt;/strong&gt;。这体现了泛型所带来的安全性。&lt;/p&gt;
&lt;p&gt;可以这么说，&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;唯一特殊的地方只是&lt;code&gt;Object&lt;/code&gt;是所有类型的超类，由于泛型的不可协变性，&lt;strong&gt;它只能表示&lt;code&gt;List&lt;/code&gt;中可以容纳所有类型的对象，却不能表示任何参数类型的&lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;则是通配符类型中的一种特例，它并没有&lt;code&gt;extend&lt;/code&gt;或&lt;code&gt;super&lt;/code&gt;这样的限制，从而可以做到引用任意参数类型的&lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;。但由于没有表示类型的符号（&lt;code&gt;E&lt;/code&gt;），在方法中无法引用这个类型，所以它只用于无需使用具体类型的方法之中，如果不是这个情况，则需要使用泛型方法（只用&lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;的&lt;strong&gt;不是&lt;/strong&gt;一个泛型方法，它具有&lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;这个固定的参数`）。&lt;/p&gt;
&lt;p&gt;但是&lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;还是不能用作上面的&lt;code&gt;unsafeAdd&lt;/code&gt;的参数，修改后会出现一条奇怪的编译错误：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;error: no suitable method found &lt;span class="k"&gt;for&lt;/span&gt; add&lt;span class="o"&gt;(&lt;/span&gt;Object&lt;span class="o"&gt;)&lt;/span&gt;
        list.add&lt;span class="o"&gt;(&lt;/span&gt;object&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        ^
method Collection.add&lt;span class="o"&gt;(&lt;/span&gt;CAP#1&lt;span class="o"&gt;)&lt;/span&gt; is not applicable
  &lt;span class="o"&gt;(&lt;/span&gt;argument mismatch&lt;span class="p"&gt;;&lt;/span&gt; Object cannot be converted to CAP#1&lt;span class="o"&gt;)&lt;/span&gt;
method List.add&lt;span class="o"&gt;(&lt;/span&gt;CAP#1&lt;span class="o"&gt;)&lt;/span&gt; is not applicable
  &lt;span class="o"&gt;(&lt;/span&gt;argument mismatch&lt;span class="p"&gt;;&lt;/span&gt; Object cannot be converted to CAP#1&lt;span class="o"&gt;)&lt;/span&gt;
where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这是因为无法将任何元素（&lt;code&gt;null&lt;/code&gt;除外）放入&lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;中。这又是为什么呢？先来看一个有限定通配符的例子：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DiffInGeneric&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;?&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;();&lt;/span&gt;
        &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;();&lt;/span&gt;
        &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Float&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;();&lt;/span&gt;
        &lt;span class="n"&gt;numbers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;();&lt;/span&gt;
        &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;第7行报出了与之前相似的编译错误：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;error: no suitable method found &lt;span class="k"&gt;for&lt;/span&gt; add&lt;span class="o"&gt;(&lt;/span&gt;Integer&lt;span class="o"&gt;)&lt;/span&gt;
    numbers.add&lt;span class="o"&gt;(&lt;/span&gt;new Integer&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
           ^
method Collection.add&lt;span class="o"&gt;(&lt;/span&gt;CAP#1&lt;span class="o"&gt;)&lt;/span&gt; is not applicable
  &lt;span class="o"&gt;(&lt;/span&gt;argument mismatch&lt;span class="p"&gt;;&lt;/span&gt; Integer cannot be converted to CAP#1&lt;span class="o"&gt;)&lt;/span&gt;
method List.add&lt;span class="o"&gt;(&lt;/span&gt;CAP#1&lt;span class="o"&gt;)&lt;/span&gt; is not applicable
  &lt;span class="o"&gt;(&lt;/span&gt;argument mismatch&lt;span class="p"&gt;;&lt;/span&gt; Integer cannot be converted to CAP#1&lt;span class="o"&gt;)&lt;/span&gt;
where CAP#1 is a fresh type-variable:
    CAP#1 extends Number from capture of ? extends Number
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这次我们可以看出错误的原因：可以将一个&lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt;传递给&lt;code&gt;List&amp;lt;? extends Number&amp;gt;&lt;/code&gt;，因为&lt;code&gt;Integer&lt;/code&gt;是&lt;code&gt;Number&lt;/code&gt;的子类，符合限定符的条件。同理，也可以将类似的对象传递给它，当然也可以把&lt;code&gt;List&amp;lt;Number&amp;gt;&lt;/code&gt;传递给它。&lt;/p&gt;
&lt;p&gt;如果允许这个对象的&lt;code&gt;add&lt;/code&gt;操作，我们无法知道这个参数是否与对象的泛型参数相同，因为我们只知道它是&lt;code&gt;Number&lt;/code&gt;的一个子类。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;?&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Parent&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Child&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;();&lt;/span&gt;
&lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;?&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Parent&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parents&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Parent&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;上面的1,2两行是完全合法的，如果允许第3行的&lt;code&gt;add&lt;/code&gt;操作，那么会把一个&lt;code&gt;Parent&lt;/code&gt;对象加入到一个实际类型是&lt;code&gt;Child&lt;/code&gt;的&lt;code&gt;List&lt;/code&gt;中，而&lt;code&gt;Parent&lt;/code&gt;is-not-a &lt;code&gt;Child&lt;/code&gt;，这破坏了Java的类型安全，是绝对不允许的。&lt;/p&gt;
&lt;p&gt;上面是有限制通配符的情况，那么针对&lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;这样的无限制通配符更是如此。因此，为了保证类型安全，不允许对&lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;或&lt;code&gt;List&amp;lt;? extends E&amp;gt;&lt;/code&gt;这样的通配符类型进行类似&lt;code&gt;add&lt;/code&gt;的操作。&lt;/p&gt;
&lt;p&gt;使用泛型方法可以避免这个问题（重申通配符类型并不是泛型方法），使用无限制通配符类型可以取代其他需要表示&lt;strong&gt;包含某一种对象类型的泛型类型&lt;/strong&gt;的情况而不是使用原生态类型&lt;code&gt;List&lt;/code&gt;。&lt;/p&gt;</content><category term="Java"></category></entry></feed>